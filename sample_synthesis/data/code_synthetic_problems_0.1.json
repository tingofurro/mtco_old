[{"problem_id": 1, "category": "sorting", "name": "rank_portfolios_by_risk", "domain": "finance", "description": "Given a list of dicts containing a portfolio name and numeric risk score, return the names sorted by increasing risk. If two risks tie, sort those names in reverse alphabetical order.", "verified": true, "reference_solution": "def rank_portfolios_by_risk(portfolios):\n    \"\"\"Return portfolio names ordered by ascending risk; if risks are equal,\n    names are ordered in reverse (descending) alphabetical order.\n    \n    portfolios : list of dicts, each with keys 'name' (str) and 'risk' (number)\n    returns     : list of names (str) in the required order\n    \"\"\"\n    # First, order by name in reverse alphabetical order so that within the same\n    # risk score the desired name ordering is already established.\n    by_name_desc = sorted(portfolios, key=lambda d: d['name'], reverse=True)\n\n    # Second, order by risk (ascending). Python's sort is *stable*, so the\n    # relative order of items with equal risk (set in the previous sort) is\n    # preserved.\n    by_risk_then_name = sorted(by_name_desc, key=lambda d: d['risk'])\n\n    # Extract the names in the computed order.\n    return [d['name'] for d in by_risk_then_name]\n", "reference_tests": [{"type": "basic", "inputs": [[{"name": "Alpha", "risk": 2}, {"name": "Beta", "risk": 1}, {"name": "Gamma", "risk": 3}]], "output": ["Beta", "Alpha", "Gamma"]}, {"type": "basic", "inputs": [[{"name": "X", "risk": 5}, {"name": "Y", "risk": 5}, {"name": "Z", "risk": 1}]], "output": ["Z", "Y", "X"]}, {"type": "edge_case", "inputs": [[{"name": "PortfolioA", "risk": 10}]], "output": ["PortfolioA"]}, {"type": "edge_case", "inputs": [[]], "output": []}, {"type": "edge_case", "inputs": [[{"name": "AAA", "risk": 0}, {"name": "BBB", "risk": 0}, {"name": "CCC", "risk": 0}]], "output": ["CCC", "BBB", "AAA"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need order of portfolio names based on risk details you receive"}, {"shard_id": 2, "shard": "Input is a list of dictionary items each with keys name and risk number"}, {"shard_id": 3, "shard": "First sort by risk smaller values should appear earlier in the names list"}, {"shard_id": 4, "shard": "When two risks match choose the higher name alphabetically to come first"}]}}, {"problem_id": 2, "category": "string_manipulation", "name": "normalize_financial_tickers", "domain": "finance", "description": "Receive mixed-case stock ticker symbols possibly containing spaces or punctuation. Return a list with duplicates removed, every symbol upper-cased, and kept in their first appearance order after cleaning.", "verified": true, "reference_solution": "import re\n\ndef normalize_financial_tickers(tickers):\n    \"\"\"Normalize a list of financial tickers.\n\n    1. Strip every character that is not a letter or digit.\n    2. Convert the remaining string to upper-case.\n    3. Skip empty results produced after cleaning.\n    4. Preserve the first appearance order while removing duplicates.\n    \"\"\"\n    seen = set()\n    normalized = []\n\n    for symbol in tickers:\n        # Remove any character that is not a letter or digit, then upper-case\n        cleaned = re.sub(r\"[^A-Za-z0-9]\", \"\", str(symbol)).upper()\n        if cleaned and cleaned not in seen:\n            seen.add(cleaned)\n            normalized.append(cleaned)\n\n    return normalized\n", "reference_tests": [{"type": "basic", "inputs": [["aapl", "MSFT ", "goog"]], "output": ["AAPL", "MSFT", "GOOG"]}, {"type": "basic", "inputs": [["Aapl", "a a p l", "AAP L", "msft"]], "output": ["AAPL", "MSFT"]}, {"type": "edge_case", "inputs": [["brk.b", "BRK B", "Brk-B"]], "output": ["BRKB"]}, {"type": "edge_case", "inputs": [["", " ", "!!!", "tsla"]], "output": ["TSLA"]}, {"type": "edge_case", "inputs": [["TSLA", "TSLA", "TSLA"]], "output": ["TSLA"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Clean a list of ticker strings while keeping first seen order"}, {"shard_id": 2, "shard": "Delete every non letter or digit then change to upper case"}, {"shard_id": 3, "shard": "Skip any symbol that becomes empty after the cleanup step"}, {"shard_id": 4, "shard": "Reject later duplicates so result shows each symbol only once"}]}}, {"problem_id": 3, "category": "math", "name": "compound_interest_schedule", "domain": "finance", "description": "Compute yearly balances of an investment given principal, yearly rate, and number of years. Use annual compounding, round each yearly balance to two decimals, and return the list including initial principal.", "verified": false, "sample_type": "code_synthetic"}, {"problem_id": 4, "category": "geometry", "name": "closest_branch_atm", "domain": "finance", "description": "Given coordinates of ATMs and a customer location, return index of the closest ATM using Euclidean distance. If two are equally near, choose the one with lower index.", "verified": true, "reference_solution": "def closest_branch_atm(atms, customer):\n    \"\"\"Return the index (0-based) of the ATM that is closest to the customer.\n    If two ATMs are equally near, the one with the lower index is chosen.\n    atms: list of (x, y) pairs or lists.\n    customer: (x, y) pair or list.\n    \"\"\"\n    if not atms:\n        return None  # or raise ValueError(\"No ATMs provided\")\n\n    cx, cy = customer\n    min_dist_sq = float('inf')\n    min_index = -1\n\n    for i, (x, y) in enumerate(atms):\n        dx = x - cx\n        dy = y - cy\n        dist_sq = dx * dx + dy * dy  # squared distance (avoids sqrt)\n        if dist_sq < min_dist_sq:\n            min_dist_sq = dist_sq\n            min_index = i\n    return min_index", "reference_tests": [{"type": "basic", "inputs": [[[0, 0], [1, 1]], [2, 2]], "output": 1}, {"type": "basic", "inputs": [[[-1, -1], [2, 3], [4, 0]], [0, 0]], "output": 0}, {"type": "edge_case", "inputs": [[[1, 0], [0, 1]], [0, 0]], "output": 0}, {"type": "edge_case", "inputs": [[[7, 7]], [2, 2]], "output": 0}, {"type": "basic", "inputs": [[[10, 10], [5, 5], [3, 4]], [6, 8]], "output": 1}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Pick nearest cash machine for a customer using straight line distance"}, {"shard_id": 2, "shard": "Input is list of machine coordinates plus one customer coordinate both as x y"}, {"shard_id": 3, "shard": "If two machines tie on distance choose the one that appears first"}, {"shard_id": 4, "shard": "Return zero based index of that machine or none when no machines exist"}]}}, {"problem_id": 5, "category": "list_processing", "name": "rolling_profit_window", "domain": "finance", "description": "Given daily profit integers and window length k, produce list of sums over every consecutive k-day interval. Return empty list if k is larger than data length.", "verified": true, "reference_solution": "def rolling_profit_window(profits, k):\n    # Return an empty list for non-positive window or if window exceeds data length\n    if k <= 0 or k > len(profits):\n        return []\n\n    # Initial window sum\n    window_sum = sum(profits[:k])\n    result = [window_sum]\n\n    # Slide the window across the list\n    for i in range(k, len(profits)):\n        window_sum += profits[i] - profits[i - k]\n        result.append(window_sum)\n\n    return result", "reference_tests": [{"type": "basic", "inputs": [[1, 2, 3, 4, 5], 3], "output": [6, 9, 12]}, {"type": "basic", "inputs": [[10, -2, 3, 5], 2], "output": [8, 1, 8]}, {"type": "edge_case", "inputs": [[1, 2, 3], 3], "output": [6]}, {"type": "edge_case", "inputs": [[4, 1], 5], "output": []}, {"type": "edge_case", "inputs": [[], 1], "output": []}, {"type": "edge_case", "inputs": [[1, 2, 3], 0], "output": []}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Turn daily profit data into rolling totals"}, {"shard_id": 2, "shard": "Input is list of integers then window length k"}, {"shard_id": 3, "shard": "For every consecutive k days sum them and collect results"}, {"shard_id": 4, "shard": "If k invalid or longer than data output empty list"}]}}, {"problem_id": 6, "category": "combinatorics", "name": "nurse_shift_reorderings", "domain": "healthcare", "description": "Return number of unique circular arrangements for n nurses around a desk where rotations are considered identical. Expect n between 1 and 15 inclusive.", "verified": true, "reference_solution": "def nurse_shift_reorderings(n):\n    \"\"\"Return the number of unique circular arrangements for n nurses.\n    In a circular arrangement, rotations are considered identical, so the count\n    is (n-1)! for n >= 1. The function assumes 1 <= n <= 15.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 1 or n > 15:\n        raise ValueError(\"n must be between 1 and 15 inclusive\")\n    # (n-1)! calculation\n    result = 1\n    for i in range(2, n):  # multiply from 2 to n-1\n        result *= i\n    return result\n", "reference_tests": [{"type": "basic", "inputs": [3], "output": 2}, {"type": "basic", "inputs": [5], "output": 24}, {"type": "edge_case", "inputs": [1], "output": 1}, {"type": "edge_case", "inputs": [2], "output": 1}, {"type": "edge_case", "inputs": [15], "output": 87178291200}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Arrange nurses round a desk count distinct seat orders"}, {"shard_id": 2, "shard": "Rotate the circle any amount and it still counts as same order"}, {"shard_id": 3, "shard": "Input is one integer n between one and fifteen output is an integer"}, {"shard_id": 4, "shard": "Sample three nurses yields two seatings follow that pattern for others"}]}}, {"problem_id": 7, "category": "date_time", "name": "next_vaccination_day", "domain": "healthcare", "description": "Given a starting date string YYYY-MM-DD and integer interval days, return next vaccination date that never falls on weekend (Saturday or Sunday). Skip weekends by pushing forward until Monday.", "verified": true, "reference_solution": "from datetime import datetime, timedelta\n\ndef next_vaccination_day(start_date: str, interval_days: int) -> str:\n    \"\"\"Return the next vaccination date (YYYY-MM-DD) that never falls on a weekend.\n    1. start_date is a string in 'YYYY-MM-DD' format.\n    2. interval_days is the number of days to add to start_date.\n    3. If the resulting date is Saturday (weekday==5) or Sunday (weekday==6),\n       push it forward to the following Monday.\n    \"\"\"\n    # Parse the input date\n    date_obj = datetime.strptime(start_date, \"%Y-%m-%d\").date()\n\n    # Add the interval\n    candidate = date_obj + timedelta(days=interval_days)\n\n    # If candidate falls on weekend, push forward to Monday\n    weekday = candidate.weekday()  # Monday=0, Sunday=6\n    if weekday == 5:  # Saturday -> push 2 days\n        candidate += timedelta(days=2)\n    elif weekday == 6:  # Sunday -> push 1 day\n        candidate += timedelta(days=1)\n\n    return candidate.strftime(\"%Y-%m-%d\")\n", "reference_tests": [{"type": "basic", "inputs": ["2023-01-01", 28], "output": "2023-01-30"}, {"type": "basic", "inputs": ["2023-08-10", 2], "output": "2023-08-14"}, {"type": "edge_case", "inputs": ["2023-08-11", 1], "output": "2023-08-14"}, {"type": "edge_case", "inputs": ["2023-08-12", 0], "output": "2023-08-14"}, {"type": "edge_case", "inputs": ["2022-12-12", 5], "output": "2022-12-19"}, {"type": "edge_case", "inputs": ["2023-12-29", 2], "output": "2024-01-01"}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Find next vaccine day that avoids weekend"}, {"shard_id": 2, "shard": "You start with YYYY-MM-DD and an integer count of days"}, {"shard_id": 3, "shard": "After adding days skip forward if landing on Saturday or Sunday"}, {"shard_id": 4, "shard": "Return the final date in same dashed format"}]}}, {"problem_id": 8, "category": "parsing", "name": "extract_icd_codes", "domain": "healthcare", "description": "From a clinical note string, return list of unique ICD-10 codes. Codes follow pattern one letter plus two digits optionally followed by a dot and up to two digits.", "verified": true, "reference_solution": "import re\n\ndef extract_icd_codes(note: str):\n    \"\"\"Extract unique ICD-10 codes from a clinical note.\n\n    A valid code:\n      \u2022 One letter (A\u2013Z or a\u2013z)\n      \u2022 Two digits\n      \u2022 Optional dot followed by one or two digits\n    The result keeps the order of first appearance and uses an uppercase leading letter.\n    \"\"\"\n    # Regex pattern: letter + 2 digits, optional \".\" + 1\u20132 digits, surrounded by word boundaries\n    pattern = re.compile(r\"\\b([A-Za-z][0-9]{2}(?:\\.[0-9]{1,2})?)\\b\")\n    seen = {}\n    for match in pattern.findall(note):\n        # Normalize so that the initial letter is uppercase, rest stays the same\n        normalized = match[0].upper() + match[1:]\n        if normalized not in seen:\n            seen[normalized] = None\n    return list(seen.keys())\n", "reference_tests": [{"type": "basic", "inputs": ["Patient diagnosed with A12 and B34.5 today."], "output": ["A12", "B34.5"]}, {"type": "basic", "inputs": ["Codes: C78.90, c78.90, D56."], "output": ["C78.90", "D56"]}, {"type": "edge_case", "inputs": ["The following code is e11.9 for diabetes."], "output": ["E11.9"]}, {"type": "edge_case", "inputs": ["No codes present."], "output": []}, {"type": "edge_case", "inputs": ["Patient has F12.3 and G45.67 conditions."], "output": ["F12.3", "G45.67"]}, {"type": "edge_case", "inputs": ["Symptoms (H60) resolved."], "output": ["H60"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Extract ICD10 codes from a single clinic note string"}, {"shard_id": 2, "shard": "Each code starts with letter followed by exactly two digits"}, {"shard_id": 3, "shard": "Optional dot can follow plus up to two extra digits"}, {"shard_id": 4, "shard": "List unique codes uppercase first letter and preserve first appearance order"}]}}, {"problem_id": 9, "category": "searching", "name": "find_first_fever", "domain": "healthcare", "description": "Given chronological temperature readings, return earliest index where temperature exceeds 38\u00b0C for two consecutive readings. Return -1 if condition never occurs.", "verified": true, "reference_solution": "def find_first_fever(readings):\n    \"\"\"Return the earliest index where temperature exceeds 38\u00b0C for two consecutive readings.\n    If such a pair doesn't exist, return -1.\n    \"\"\"\n    if not readings or len(readings) < 2:\n        return -1\n    for i in range(len(readings) - 1):\n        if readings[i] > 38 and readings[i + 1] > 38:\n            return i\n    return -1", "reference_tests": [{"type": "basic", "inputs": [[36.5, 38.2, 39.0, 37.8]], "output": 1}, {"type": "basic", "inputs": [[36, 37, 38, 37]], "output": -1}, {"type": "edge_case", "inputs": [[39, 39]], "output": 0}, {"type": "edge_case", "inputs": [[]], "output": -1}, {"type": "edge_case", "inputs": [[38, 38.5, 38.6]], "output": 1}, {"type": "edge_case", "inputs": [[37, 39, 37, 39, 39]], "output": 3}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Detect earliest consecutive fever events in a timeline of temperatures"}, {"shard_id": 2, "shard": "Given a chronological list of celsius readings as input"}, {"shard_id": 3, "shard": "A fever event is two readings in a row higher than 38"}, {"shard_id": 4, "shard": "Output the index of the first member or minus one if none"}]}}, {"problem_id": 10, "category": "hashing", "name": "anonymize_patient_ids", "domain": "healthcare", "description": "Map patient IDs (strings) to anonymized hex digests using SHA-256, but keep only first 12 characters of each digest. Return list preserving original order.", "verified": true, "reference_solution": "import hashlib\n\ndef anonymize_patient_ids(patient_ids):\n    \"\"\"Return a list with each patient id replaced by the first 12 hex characters\n    of its SHA-256 digest, preserving the original order.\n    \"\"\"\n    return [hashlib.sha256(pid.encode('utf-8')).hexdigest()[:12] for pid in patient_ids]\n", "reference_tests": [{"type": "basic", "inputs": [[""]], "output": ["e3b0c44298fc"]}, {"type": "basic", "inputs": [["a", "abc"]], "output": ["ca978112ca1b", "ba7816bf8f01"]}, {"type": "edge_case", "inputs": [["a", "a"]], "output": ["ca978112ca1b", "ca978112ca1b"]}, {"type": "edge_case", "inputs": [[]], "output": []}, {"type": "basic", "inputs": [["The quick brown fox jumps over the lazy dog"]], "output": ["d7a8fbb307d7"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Swap every patient id with a non identifying hex code string"}, {"shard_id": 2, "shard": "You get a list of ids and must return a list same size"}, {"shard_id": 3, "shard": "Hex code comes from hashing each id using SHA two fifty six algorithm"}, {"shard_id": 4, "shard": "Only first twelve hex characters kept and keep ordering exactly unchanged"}]}}, {"problem_id": 11, "category": "set_operations", "name": "mutual_followers_count", "domain": "social_media", "description": "Given two lists of user IDs for followers of accounts A and B, return count of users who follow both, ignoring duplicate IDs within each list.", "verified": true, "reference_solution": "def mutual_followers_count(followers_a, followers_b):\n    \"\"\"Return the number of unique user IDs that appear in both followers_a and followers_b.\n    Duplicate IDs inside each input list are ignored.\n    \"\"\"\n    # Convert both lists to sets to eliminate duplicates and enable fast intersection\n    set_a = set(followers_a)\n    set_b = set(followers_b)\n\n    # Intersection gives users following both accounts\n    mutual = set_a & set_b\n\n    # Return the count of mutual followers\n    return len(mutual)\n", "reference_tests": [{"type": "basic", "inputs": [[1, 2, 3, 4], [3, 4, 5]], "output": 2}, {"type": "basic", "inputs": [[10, 20, 20, 30], [20, 40, 10, 10]], "output": 2}, {"type": "edge_case", "inputs": [[], [1, 2, 3]], "output": 0}, {"type": "edge_case", "inputs": [[1, 1, 1], [1, 1]], "output": 1}, {"type": "edge_case", "inputs": [[], []], "output": 0}, {"type": "basic", "inputs": [[100, 200, 300], [400, 500, 600]], "output": 0}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need number of users following both accounts duplicates irrelevant"}, {"shard_id": 2, "shard": "Input two lists of user ids maybe with repeats"}, {"shard_id": 3, "shard": "Treat each list as unique set then find shared ids"}, {"shard_id": 4, "shard": "Return how many shared ids count zero allowed"}]}}, {"problem_id": 12, "category": "bitwise", "name": "privacy_flag_mask", "domain": "social_media", "description": "Combine list of integer privacy flags by bitwise OR to produce single summary flag. Then clear bit 0 (least significant) if total number of posts is zero.", "verified": true, "reference_solution": "def privacy_flag_mask(flags, total_posts):\n    \"\"\"Combine privacy flags with bitwise OR and clear bit 0 if no posts.\n\n    Args:\n        flags (list[int]): List of integer privacy flags.\n        total_posts (int): Total number of posts.\n\n    Returns:\n        int: Summary privacy flag after processing.\n    \"\"\"\n    # Step 1: Combine all flags via bitwise OR\n    summary = 0\n    for f in flags:\n        summary |= int(f)\n\n    # Step 2: If total_posts is zero, clear least-significant bit\n    if total_posts == 0:\n        summary &= ~1  # clear bit 0\n\n    return summary", "reference_tests": [{"type": "basic", "inputs": [[1, 2, 4], 5], "output": 7}, {"type": "basic", "inputs": [[1, 2, 4], 0], "output": 6}, {"type": "edge_case", "inputs": [[], 3], "output": 0}, {"type": "edge_case", "inputs": [[], 0], "output": 0}, {"type": "edge_case", "inputs": [[3, 8], 0], "output": 10}, {"type": "basic", "inputs": [[16, 32, 1], 12], "output": 49}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Merge many privacy numeric flags into one combined flag"}, {"shard_id": 2, "shard": "Do a bitwise OR across every flag value"}, {"shard_id": 3, "shard": "When there are zero posts clear bit zero in result"}, {"shard_id": 4, "shard": "Takes flag list and count outputs single summary integer flag"}]}}, {"problem_id": 13, "category": "simulation", "name": "simulate_retweet_chain", "domain": "social_media", "description": "Given seed tweet ID and list of pairs (retweeter, parent), trace chain until original tweet. Return list of IDs from original to latest. Assume valid acyclic chain.", "verified": true, "reference_solution": "def simulate_retweet_chain(seed_id, retweet_pairs):\n    \"\"\"Return the list of tweet IDs from the original tweet to the given seed tweet.\n\n    Parameters\n    ----------\n    seed_id : int or str\n        The id of the most recent (seed) tweet/retweet.\n    retweet_pairs : list[tuple|list]\n        Each pair (retweeter, parent) means *retweeter* is a retweet of *parent*.\n\n    Returns\n    -------\n    list\n        Tweet IDs starting with the original tweet id and ending with *seed_id*.\n    \"\"\"\n    # Build a mapping: child -> parent\n    parent_of = {}\n    for child, parent in retweet_pairs:\n        parent_of[child] = parent\n\n    chain = [seed_id]\n    current = seed_id\n    # Walk up until we find the original tweet (which has no parent recorded)\n    while current in parent_of:\n        current = parent_of[current]\n        chain.append(current)\n\n    # We walked from latest to original; reverse to original -> latest\n    return chain[::-1]\n", "reference_tests": [{"type": "basic", "inputs": [3, [[3, 2], [2, 1]]], "output": [1, 2, 3]}, {"type": "edge_case", "inputs": [10, []], "output": [10]}, {"type": "basic", "inputs": [5, [[5, 4], [3, 2], [4, 3]]], "output": [2, 3, 4, 5]}, {"type": "edge_case", "inputs": ["d", [["b", "a"], ["c", "b"], ["d", "c"]]], "output": ["a", "b", "c", "d"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Trace tweet history from original source up to provided newest tweet id"}, {"shard_id": 2, "shard": "Input has the seed id and pairs showing who retweeted whom"}, {"shard_id": 3, "shard": "No loops exist so you can walk parent links back safely"}, {"shard_id": 4, "shard": "Return ids ordered earliest original first latest seed last"}]}}, {"problem_id": 14, "category": "recursion", "name": "expand_comment_thread", "domain": "social_media", "description": "Given dictionary mapping comment_id to list of reply_ids, return flattened list of all descendants for a starting comment, depth-first preorder.", "verified": true, "reference_solution": "def expand_comment_thread(thread_map, start_id):\n    \"\"\"Return a depth-first (pre-order) flattened list of all descendants of\n    `start_id` using the mapping `thread_map` where each key maps to a list of\n    its direct reply IDs.\n    \n    Parameters\n    ----------\n    thread_map : dict\n        Mapping from comment ID to list of reply IDs.\n    start_id : hashable\n        The comment ID whose descendants are to be expanded.\n    \n    Returns\n    -------\n    list\n        List containing all descendant IDs in depth-first pre-order.  The\n        starting ID itself is not included, only its replies and their\n        descendants.\n    \"\"\"\n    result = []\n\n    def dfs(cid):\n        # Retrieve the direct children (empty list if key absent)\n        for child in thread_map.get(cid, []):\n            result.append(child)\n            dfs(child)\n\n    dfs(start_id)\n    return result", "reference_tests": [{"type": "basic", "inputs": [{"1": ["2"], "2": ["3"], "3": []}, "1"], "output": ["2", "3"]}, {"type": "basic", "inputs": [{"1": ["2", "3"], "2": ["4"], "3": [], "4": []}, "1"], "output": ["2", "4", "3"]}, {"type": "edge_case", "inputs": [{"10": []}, "10"], "output": []}, {"type": "edge_case", "inputs": [{"1": ["2"]}, "1"], "output": ["2"]}, {"type": "edge_case", "inputs": [{}, "X"], "output": []}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Get every reply under one comment in order depth first"}, {"shard_id": 2, "shard": "We receive two inputs one comment map and the starting comment id"}, {"shard_id": 3, "shard": "Output is a flat list of all descendant ids without the root"}, {"shard_id": 4, "shard": "For comment one with children two then three produce two then three"}]}}, {"problem_id": 15, "category": "counting", "name": "hashtag_frequency", "domain": "social_media", "description": "Extract hashtags (case-insensitive) from list of posts. Return dictionary mapping lowercase hashtag to count, but include only those occurring at least twice.", "verified": true, "reference_solution": "import re\nfrom collections import Counter\n\ndef hashtag_frequency(posts):\n    \"\"\"Return a dictionary mapping lowercase hashtags (without '#') to their\n    frequency, considering only those that appear at least twice across the\n    provided list of posts. The matching is case-insensitive and considers\n    sequences of word characters (letters, digits, underscore) that follow a\n    leading '#'.\n    \"\"\"\n    counter = Counter()\n    pattern = re.compile(r'#(\\w+)')  # capture word chars after '#'\n\n    for post in posts:\n        for tag in pattern.findall(post):\n            counter[tag.lower()] += 1\n\n    # Keep only hashtags that occur at least twice\n    return {tag: cnt for tag, cnt in counter.items() if cnt >= 2}", "reference_tests": [{"type": "basic", "inputs": [["I love #Python and #AI", "Learning #python is fun", "#AI will rule the world"]], "output": {"python": 2, "ai": 2}}, {"type": "basic", "inputs": [["#one #two", "#three #Four"]], "output": {}}, {"type": "edge_case", "inputs": [[]], "output": {}}, {"type": "edge_case", "inputs": [["Testing #Tag_1 #tag_1 #TAG_2", "Another #tag_1 post"]], "output": {"tag_1": 3}}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Extract hashtags from posts case not important"}, {"shard_id": 2, "shard": "Input is list of post texts output mapping tag to frequency"}, {"shard_id": 3, "shard": "Convert every tag to lowercase before counting"}, {"shard_id": 4, "shard": "Return only tags that appear at least two times example python returns two"}]}}, {"problem_id": 16, "category": "greedy", "name": "minimize_delivery_distance", "domain": "geography", "description": "Given sorted list of house coordinates on a line and k post offices, greedily choose k locations from houses minimizing sum of absolute distances. Return chosen coordinates order preserved.", "verified": true, "reference_solution": "def minimize_delivery_distance(houses, k):\n    \"\"\"Return a list with the locations (house coordinates) where the k post offices\n    should be placed so that the sum of the distances from every house to its\n    closest post-office is minimal.  The houses list is already sorted.\n    The returned list keeps the natural left-to-right order.\n    \"\"\"\n    n = len(houses)\n    if k >= n:                     # one office per house \u2013 trivial optimum\n        return houses[:]\n    if k == 1:                     # one office \u2013 choose the median house (lower one if even)\n        return [houses[(n - 1)//2]]\n\n    # Prefix sums to compute interval distances fast\n    prefix = [0]\n    for h in houses:\n        prefix.append(prefix[-1] + h)\n\n    # Pre\u2013compute cost of serving houses[l..r] (inclusive) with one office\n    # placed at its median (lower median when even).\n    cost = [[0]*n for _ in range(n)]\n    for l in range(n):\n        for r in range(l, n):\n            m = (l + r) // 2                       # index of median house (lower if even)\n            # distance for left side\n            left = houses[m]*(m - l) - (prefix[m] - prefix[l])\n            # distance for right side\n            right = (prefix[r+1] - prefix[m+1]) - houses[m]*(r - m)\n            cost[l][r] = left + right\n\n    # DP: dp[p][i] \u2013 minimal distance for first i houses (0..i-1) with p offices\n    INF = float('inf')\n    dp = [[INF]*(n+1) for _ in range(k+1)]\n    prev = [[-1]*(n+1) for _ in range(k+1)]     # where previous segment ends\n    dp[0][0] = 0\n\n    for p in range(1, k+1):\n        # we need at least p houses to place p offices, start index accordingly\n        for i in range(1, n+1):\n            # try every possible split point t (first t houses served by p-1 offices)\n            # segment t .. i-1 served by new office\n            best_val = INF\n            best_t = -1\n            # earliest t is p-1 to ensure there are t houses for p-1 offices\n            for t in range(p-1, i):\n                val = dp[p-1][t] + cost[t][i-1]\n                if val < best_val:\n                    best_val = val\n                    best_t = t\n            dp[p][i] = best_val\n            prev[p][i] = best_t\n\n    # Reconstruct chosen positions (medians of each segment)\n    res = []\n    p, i = k, n\n    while p > 0:\n        t = prev[p][i]\n        l, r = t, i-1\n        m = (l + r) // 2\n        res.append(houses[m])\n        i = t\n        p -= 1\n\n    return res[::-1]", "reference_tests": [{"type": "basic", "inputs": [[1, 2, 3, 4, 5, 100], 2], "output": [3, 100]}, {"type": "basic", "inputs": [[1, 2, 3, 4], 1], "output": [2]}, {"type": "edge_case", "inputs": [[5, 10, 15], 3], "output": [5, 10, 15]}, {"type": "basic", "inputs": [[1, 5, 9, 14, 20, 30], 3], "output": [5, 14, 30]}, {"type": "edge_case", "inputs": [[0, 0, 0, 10], 2], "output": [0, 10]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need k post offices placed among houses for smallest travel"}, {"shard_id": 2, "shard": "Input is sorted coordinates of houses plus integer k"}, {"shard_id": 3, "shard": "Goal is minimize sum of absolute distances to nearest office"}, {"shard_id": 4, "shard": "Output selected house positions in their original left to right order"}]}}, {"problem_id": 17, "category": "formatting", "name": "format_country_codes", "domain": "geography", "description": "Convert list of two-letter country codes to uppercase, group them three per line separated by commas, final line may have fewer. Return the multiline string with no trailing comma.", "verified": true, "reference_solution": "def format_country_codes(codes):\n    \"\"\"Convert country codes to uppercase and arrange them three per line.\n\n    Parameters\n    ----------\n    codes : list of str\n        List containing two-letter (or generally short) country codes.\n\n    Returns\n    -------\n    str\n        Multiline string where codes are uppercase, grouped three per line\n        separated by commas. No trailing comma or trailing newline is added.\n    \"\"\"\n    # Upper-case all codes first\n    upper_codes = [code.upper() for code in codes]\n\n    # Group into chunks of three and join appropriately\n    lines = []\n    for i in range(0, len(upper_codes), 3):\n        chunk = upper_codes[i:i + 3]\n        lines.append(\",\".join(chunk))\n\n    # Join lines with newline, but if no codes return empty string\n    return \"\\n\".join(lines)\n", "reference_tests": [{"type": "basic", "inputs": [["us", "ca", "mx"]], "output": "US,CA,MX"}, {"type": "basic", "inputs": [["us", "ca", "mx", "uk", "fr"]], "output": "US,CA,MX\nUK,FR"}, {"type": "edge_case", "inputs": [["aa", "bb", "cc", "dd", "ee", "ff"]], "output": "AA,BB,CC\nDD,EE,FF"}, {"type": "edge_case", "inputs": [["in"]], "output": "IN"}, {"type": "edge_case", "inputs": [[]], "output": ""}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Take a list of country codes and give back a neat multiline string"}, {"shard_id": 2, "shard": "Make every code uppercase before doing anything else"}, {"shard_id": 3, "shard": "Place three codes per line joined by comma leaving no extra comma at end"}, {"shard_id": 4, "shard": "Last line can hold fewer codes empty input returns blank string"}]}}, {"problem_id": 18, "category": "validation", "name": "check_lat_lon", "domain": "geography", "description": "Validate latitude-longitude string \"lat,lon\" ensuring lat between -90 and 90, lon between -180 and 180, each with optional sign and decimals. Return tuple of floats if valid, else None.", "verified": false, "sample_type": "code_synthetic"}, {"problem_id": 19, "category": "statistics", "name": "population_weighted_centroid", "domain": "geography", "description": "Given list of triples (lat, lon, population), compute weighted average latitude and longitude. Round result to five decimals and return tuple.", "sample_type": "code_synthetic"}, {"problem_id": 20, "category": "filtering", "name": "filter_border_regions", "domain": "geography", "description": "From list of region dicts containing 'name' and boolean 'is_border', return list of names where is_border is True but name does not begin with letter X.", "verified": true, "reference_solution": "def filter_border_regions(regions):\n    \"\"\"Return a list with the names of regions whose 'is_border' field is True\n    and whose name does not start with the uppercase letter 'X'.\n\n    Parameters\n    ----------\n    regions : list[dict]\n        Each dict must contain at least the keys 'name' (str) and 'is_border' (bool).\n\n    Returns\n    -------\n    list[str]\n        Names that satisfy the given conditions, preserving the original order.\n    \"\"\"\n    if not isinstance(regions, list):\n        raise TypeError(\"Input must be a list of dictionaries.\")\n\n    filtered = []\n    for entry in regions:\n        # Validate minimal structure without being overly strict\n        if not isinstance(entry, dict):\n            raise TypeError(\"Each item in the list must be a dictionary.\")\n        if 'name' not in entry or 'is_border' not in entry:\n            raise KeyError(\"Each dictionary must have 'name' and 'is_border' keys.\")\n\n        name = entry['name']\n        is_border = entry['is_border']\n\n        if isinstance(name, str) and isinstance(is_border, bool):\n            if is_border and not name.startswith('X'):\n                filtered.append(name)\n        else:\n            raise TypeError(\"'name' must be a string and 'is_border' must be a boolean.\")\n\n    return filtered\n", "reference_tests": [{"type": "basic", "inputs": [[{"name": "Canada", "is_border": true}, {"name": "Xenon", "is_border": true}, {"name": "USA", "is_border": false}]], "output": ["Canada"]}, {"type": "edge_case", "inputs": [[]], "output": []}, {"type": "basic", "inputs": [[{"name": "Brazil", "is_border": true}, {"name": "Argentina", "is_border": true}]], "output": ["Brazil", "Argentina"]}, {"type": "edge_case", "inputs": [[{"name": "xenia", "is_border": true}, {"name": "Xavier", "is_border": true}]], "output": ["xenia"]}, {"type": "edge_case", "inputs": [[{"name": "XCountry", "is_border": true}]], "output": []}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need names of border regions from given records"}, {"shard_id": 2, "shard": "Each record has name word plus is_border boolean flag"}, {"shard_id": 3, "shard": "Skip any name that begins with uppercase X character"}, {"shard_id": 4, "shard": "Return list of selected names in same order"}]}}, {"problem_id": 21, "category": "sorting", "name": "gradebook_sort", "domain": "education", "description": "Sort list of tuples (student, score) by descending score, breaking ties by alphabetical student name. Return sorted list.", "verified": true, "reference_solution": "def gradebook_sort(records):\n    \"\"\"Sort a list of (student, score) tuples by descending score.\n    If scores are equal, sort alphabetically by the student's name.\n    Args:\n        records (list[tuple[str, int|float]]): The gradebook records.\n    Returns:\n        list[tuple[str, int|float]]: Sorted list following the criteria.\n    \"\"\"\n    # Using negative score for descending order and name for tie-break in ascending\n    return sorted(records, key=lambda item: (-item[1], item[0]))", "reference_tests": [{"type": "basic", "inputs": [[["Alice", 88], ["Bob", 95], ["Charlie", 90]]], "output": [["Bob", 95], ["Charlie", 90], ["Alice", 88]]}, {"type": "basic", "inputs": [[["Alice", 90], ["Bob", 90], ["Charlie", 85]]], "output": [["Alice", 90], ["Bob", 90], ["Charlie", 85]]}, {"type": "edge_case", "inputs": [[]], "output": []}, {"type": "basic", "inputs": [[["Dave", 72.5], ["Eve", 72.5], ["Frank", 100.0]]], "output": [["Frank", 100.0], ["Dave", 72.5], ["Eve", 72.5]]}, {"type": "edge_case", "inputs": [[["Anna", -10], ["Bella", -5], ["Cara", -5]]], "output": [["Bella", -5], ["Cara", -5], ["Anna", -10]]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Sort student records by performance then name"}, {"shard_id": 2, "shard": "Each record is name score pair given in list"}, {"shard_id": 3, "shard": "Higher score comes first equal scores use alphabetical name"}, {"shard_id": 4, "shard": "Return reordered list of the same pairs"}]}}, {"problem_id": 22, "category": "string_manipulation", "name": "camel_to_snake_identifiers", "domain": "education", "description": "Convert list of CamelCase variable names to snake_case. Preserve consecutive uppercase letters as single word (e.g., 'HTMLParser'\u2192'html_parser'). Return converted list.", "verified": true, "reference_solution": "import re\n\ndef camel_to_snake_identifiers(identifiers):\n    \"\"\"Convert a list of CamelCase identifiers to snake_case while\n    keeping consecutive uppercase sequences (acronyms) together.\n    \n    Example: [\"HTMLParser\"] -> [\"html_parser\"]\n    \"\"\"\n    converted = []\n    for name in identifiers:\n        # Insert underscore between a lowercase/number and uppercase letter\n        # and between an acronym and the following capitalised word.\n        step1 = re.sub(r'(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n        step2 = re.sub(r'([a-z0-9])([A-Z])', r'\\1_\\2', step1)\n        converted.append(step2.lower())\n    return converted", "reference_tests": [{"type": "basic", "inputs": [["CamelCase"]], "output": ["camel_case"]}, {"type": "basic", "inputs": [["HTMLParser"]], "output": ["html_parser"]}, {"type": "basic", "inputs": [["getURLResponse"]], "output": ["get_url_response"]}, {"type": "edge_case", "inputs": [["already_snake"]], "output": ["already_snake"]}, {"type": "edge_case", "inputs": [["JSON2XMLConverter", "MyHTTPServer"]], "output": ["json2_xml_converter", "my_http_server"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need to change CamelCase names into snake style with underscores"}, {"shard_id": 2, "shard": "Do not break chains of capital letters treat them one word"}, {"shard_id": 3, "shard": "Input list outputs list same order all lower case words joined underscore"}, {"shard_id": 4, "shard": "For example HTMLParser becomes html underscore parser in result"}]}}, {"problem_id": 23, "category": "math", "name": "average_grade_drop", "domain": "education", "description": "Given list of ordered test scores, compute largest drop between any two consecutive scores, returning 0 if scores never decrease.", "verified": true, "reference_solution": "def average_grade_drop(scores):\n    \"\"\"Compute the largest drop between any two consecutive test scores.\n\n    Parameters\n    ----------\n    scores : list of int or float\n        Ordered list of test scores.\n\n    Returns\n    -------\n    int or float\n        The maximum decrease between consecutive scores. Returns 0 if there is\n        no decrease or the list has fewer than two elements.\n    \"\"\"\n    if not scores or len(scores) < 2:\n        return 0\n\n    max_drop = 0\n    for prev, curr in zip(scores, scores[1:]):\n        drop = prev - curr\n        if drop > max_drop:\n            max_drop = drop\n    return max_drop", "reference_tests": [{"type": "basic", "inputs": [[100, 90, 95, 80]], "output": 15}, {"type": "basic", "inputs": [[1, 2, 3, 4]], "output": 0}, {"type": "edge_case", "inputs": [[80]], "output": 0}, {"type": "edge_case", "inputs": [[]], "output": 0}, {"type": "basic", "inputs": [[90, 70, 70, 60]], "output": 20}, {"type": "edge_case", "inputs": [[100, 90, 90, 95, 85, 85, 70]], "output": 15}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Find biggest drop between consecutive exam scores"}, {"shard_id": 2, "shard": "You receive a list of numbers in given order"}, {"shard_id": 3, "shard": "If scores never decrease or list tiny return zero"}, {"shard_id": 4, "shard": "Example 100 90 95 80 should reply 15"}]}}, {"problem_id": 24, "category": "geometry", "name": "classroom_projector_area", "domain": "education", "description": "Given four corner coordinates of rectangular projection on wall, compute its area. Points might be unordered; use distance formula defensively.", "verified": true, "reference_solution": "import math\n\ndef classroom_projector_area(points):\n    \"\"\"Compute the area of a rectangle given its four corner points.\n    The points can be supplied in any order (clock-wise, counter clock-wise, or random).\n    \n    Parameters\n    ----------\n    points : list[list[float] | tuple[float, float]]\n        A list with four items, each an (x, y) coordinate.\n    \n    Returns\n    -------\n    float\n        The (positive) area of the rectangle.\n    \"\"\"\n    if len(points) != 4:\n        raise ValueError(\"Exactly four points are required\")\n\n    # Convert to list of tuples (mutable safety / ensure numeric length 2)\n    pts = [tuple(p) for p in points]\n\n    # Step 1: compute centroid\n    cx = sum(p[0] for p in pts) / 4.0\n    cy = sum(p[1] for p in pts) / 4.0\n\n    # Step 2: sort points by polar angle around centroid so that they\n    # form a non-intersecting polygon (convex hull of rectangle).\n    def angle(p):\n        return math.atan2(p[1] - cy, p[0] - cx)\n\n    ordered = sorted(pts, key=angle)\n\n    # Step 3: compute area using the shoelace formula.\n    area = 0.0\n    for i in range(4):\n        x1, y1 = ordered[i]\n        x2, y2 = ordered[(i + 1) % 4]\n        area += x1 * y2 - x2 * y1\n    area = abs(area) / 2.0\n    return area", "reference_tests": [{"type": "basic", "inputs": [[[0, 0], [4, 0], [4, 3], [0, 3]]], "output": 12.0}, {"type": "basic", "inputs": [[[0, 0], [1, 1], [2, 0], [1, -1]]], "output": 2.0}, {"type": "edge_case", "inputs": [[[5, 0], [6, 3], [1, 3], [0, 0]]], "output": 15.0}, {"type": "basic", "inputs": [[[-2, -1], [2, -1], [2, 1], [-2, 1]]], "output": 8.0}, {"type": "edge_case", "inputs": [[[1, 2], [4, 6], [1, 10], [-2, 6]]], "output": 24.0}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Compute rectangle area on a plane given its four corner spots"}, {"shard_id": 2, "shard": "Receive four x y pairs in list order could be totally random"}, {"shard_id": 3, "shard": "Return positive float with area example corners zero zero four three gives twelve"}, {"shard_id": 4, "shard": "Algorithm must not assume order use geometry distance or angle checks"}]}}, {"problem_id": 25, "category": "list_processing", "name": "split_into_semesters", "domain": "education", "description": "Given course list and semester size n, return nested list of courses per semester. Last semester may have fewer; raise ValueError if n<1.", "verified": true, "reference_solution": "def split_into_semesters(courses, n):\n    \"\"\"Split the list of courses into sublists of length n (a semester).\n    The last sublist may contain fewer than n courses.\n    Raise ValueError if n is not a positive integer (n < 1).\"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Semester size must be a positive integer greater than 0\")\n\n    # Build the list of semesters\n    semesters = []\n    for i in range(0, len(courses), n):\n        semesters.append(courses[i:i + n])\n    return semesters", "reference_tests": [{"type": "basic", "inputs": [["CS101", "CS102", "CS103", "CS104"], 2], "output": [["CS101", "CS102"], ["CS103", "CS104"]]}, {"type": "basic", "inputs": [[1, 2, 3, 4, 5, 6, 7], 3], "output": [[1, 2, 3], [4, 5, 6], [7]]}, {"type": "edge_case", "inputs": [[], 2], "output": []}, {"type": "edge_case", "inputs": [["A", "B"], 1], "output": [["A"], ["B"]]}, {"type": "edge_case", "inputs": [[10, 20], 5], "output": [[10, 20]]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need to partition course lineup into equal sized semesters"}, {"shard_id": 2, "shard": "Accept two arguments course array and positive semester size number"}, {"shard_id": 3, "shard": "Produce nested list each inner length n final may be smaller"}, {"shard_id": 4, "shard": "If size less than one raise ValueError no grouping performed"}]}}, {"problem_id": 26, "category": "combinatorics", "name": "possible_loot_combinations", "domain": "gaming", "description": "Return count of ways to reach exact target score using unlimited items with individual scores given. Order of items doesn't matter.", "verified": true, "reference_solution": "def possible_loot_combinations(target, scores):\n    \"\"\"Return the number of unordered combinations of the given scores that sum exactly\n    to the target. Each score can be used an unlimited number of times.\n    \"\"\"\n    # Negative target cannot be reached.\n    if target < 0:\n        return 0\n    # Using a set removes duplicate item scores, preserving correctness.\n    unique_scores = sorted(set(filter(lambda x: x > 0, scores)))\n    # Edge-case: no positive scores.\n    if not unique_scores:\n        return 1 if target == 0 else 0\n\n    # dp[i] = number of ways to reach score i.\n    dp = [0] * (target + 1)\n    dp[0] = 1  # One way to reach score 0: pick nothing.\n\n    for s in unique_scores:\n        for t in range(s, target + 1):\n            dp[t] += dp[t - s]\n\n    return dp[target]\n", "reference_tests": [{"type": "basic", "inputs": [5, [1, 2, 5]], "output": 4}, {"type": "basic", "inputs": [3, [2]], "output": 0}, {"type": "edge_case", "inputs": [0, [1, 2]], "output": 1}, {"type": "edge_case", "inputs": [10, [2, 3, 5, 6]], "output": 5}, {"type": "edge_case", "inputs": [3, [1, 1, 2]], "output": 2}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Count combinations that exactly reach a goal using given scores"}, {"shard_id": 2, "shard": "Input one target integer and a list of item score integers"}, {"shard_id": 3, "shard": "Items may be chosen unlimited times order does not matter duplicates ignored"}, {"shard_id": 4, "shard": "Output the number of such combinations if none then zero else count"}]}}, {"problem_id": 27, "category": "date_time", "name": "daily_login_streaks", "domain": "gaming", "description": "Given sorted list of login date strings, return longest consecutive streak length. Dates are in YYYY-MM-DD format with no duplicates.", "verified": true, "reference_solution": "from datetime import datetime, timedelta\n\ndef daily_login_streaks(dates):\n    \"\"\"Return the length of the longest consecutive login streak.\n    dates: a sorted list of unique date strings in 'YYYY-MM-DD' format.\n    \"\"\"\n    if not dates:\n        return 0\n\n    # Convert strings to date objects for easy arithmetic\n    date_objs = [datetime.strptime(d, \"%Y-%m-%d\").date() for d in dates]\n\n    max_streak = 1\n    current_streak = 1\n\n    for prev, curr in zip(date_objs, date_objs[1:]):\n        if curr - prev == timedelta(days=1):\n            current_streak += 1\n        else:\n            current_streak = 1\n        if current_streak > max_streak:\n            max_streak = current_streak\n\n    return max_streak\n", "reference_tests": [{"type": "basic", "inputs": [["2023-01-01", "2023-01-02", "2023-01-05", "2023-01-06", "2023-01-07"]], "output": 3}, {"type": "edge_case", "inputs": [[]], "output": 0}, {"type": "basic", "inputs": [["2023-03-10", "2023-03-11", "2023-03-12", "2023-03-13", "2023-03-14", "2023-03-15"]], "output": 6}, {"type": "edge_case", "inputs": [["2023-01-01", "2023-01-03", "2023-01-05"]], "output": 1}, {"type": "edge_case", "inputs": [["2020-02-28", "2020-02-29", "2020-03-01"]], "output": 3}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Find the maximum consecutive login streak length from provided dates"}, {"shard_id": 2, "shard": "Input is sorted list of unique date strings like 2023-03-14"}, {"shard_id": 3, "shard": "Return integer length of longest run of back to back days"}, {"shard_id": 4, "shard": "Example list 2023-01-01 2023-01-02 2023-01-05 2023-01-06 2023-01-07 yields 3"}]}}, {"problem_id": 28, "category": "parsing", "name": "decode_save_file", "domain": "gaming", "description": "Parse save-file string of key=value pairs separated by semicolons; numeric values should become ints. Return dictionary with keys preserved order of appearance.", "verified": true, "reference_solution": "def decode_save_file(save_str):\n    \"\"\"Decode a save-file string of the form 'key=value;key2=value2;...'.\n    Numeric values (optionally starting with a minus sign) are converted\n    to ints. The order of keys is preserved in the returned dictionary.\n    \"\"\"\n    result = {}\n    if not save_str:\n        return result\n\n    # Split on semicolons; ignore empty segments (e.g., trailing ';')\n    for segment in save_str.split(';'):\n        if not segment:\n            continue\n        if '=' not in segment:\n            # If no '=' present, treat whole segment as a key with empty string value\n            key, value = segment, ''\n        else:\n            key, value = segment.split('=', 1)\n        # Strip surrounding whitespace from key/value\n        key = key.strip()\n        value = value.strip()\n\n        # Detect integer (handles optional leading '-')\n        if value.lstrip('-').isdigit():\n            try:\n                value = int(value)\n            except ValueError:\n                pass  # Keep original string if conversion fails for any reason\n        result[key] = value\n    return result", "reference_tests": [{"type": "basic", "inputs": ["health=100;mana=50;name=Link"], "output": {"health": 100, "mana": 50, "name": "Link"}}, {"type": "edge_case", "inputs": ["lives=-3;level=2"], "output": {"lives": -3, "level": 2}}, {"type": "edge_case", "inputs": ["code=007bond;secret=42"], "output": {"code": "007bond", "secret": 42}}, {"type": "edge_case", "inputs": ["x=1;y=2;z=three;"], "output": {"x": 1, "y": 2, "z": "three"}}, {"type": "edge_case", "inputs": [""], "output": {}}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need dictionary from a save string keys keep listed order"}, {"shard_id": 2, "shard": "Pairs shaped like key=value appear separated by semicolons"}, {"shard_id": 3, "shard": "If value looks like whole number treat it as int else keep text"}, {"shard_id": 4, "shard": "Blank input returns empty dict plus trailing separators ignored"}]}}, {"problem_id": 29, "category": "searching", "name": "first_unopened_chest", "domain": "gaming", "description": "Given list of booleans representing chests opened, return lowest index of False. Return -1 if all opened.", "sample_type": "code_synthetic"}, {"problem_id": 30, "category": "hashing", "name": "unique_player_signature", "domain": "gaming", "description": "Concatenate player username with join-date, hash using MD5, return first eight characters uppercase.", "verified": true, "reference_solution": "import hashlib\n\ndef unique_player_signature(username, join_date):\n    \"\"\"Return the first eight characters (uppercase) of the MD5 hash of the\n    concatenation of username and join_date. Both inputs are converted to\n    strings before concatenation to ensure robustness.\n    \"\"\"\n    # Ensure inputs are strings\n    combined = str(username) + str(join_date)\n    # Generate MD5 hash\n    md5_hash = hashlib.md5(combined.encode('utf-8')).hexdigest()\n    # Return first eight characters in uppercase\n    return md5_hash[:8].upper()", "reference_tests": [{"type": "basic", "inputs": ["a", ""], "output": "0CC175B9"}, {"type": "basic", "inputs": ["", ""], "output": "D41D8CD9"}, {"type": "basic", "inputs": ["ab", "c"], "output": "90015098"}, {"type": "edge_case", "inputs": ["", "password"], "output": "5F4DCC3B"}, {"type": "edge_case", "inputs": ["a", "b"], "output": "187EF443"}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Make a reproducible tag by merging a players username with when they joined"}, {"shard_id": 2, "shard": "The function takes two strings username and date and returns eight character code"}, {"shard_id": 3, "shard": "Generate md5 digest from the concatenated strings to build the identifier"}, {"shard_id": 4, "shard": "Keep only first eight characters convert to uppercase and present it"}]}}, {"problem_id": 31, "category": "set_operations", "name": "science_common_genes", "domain": "science", "description": "Return sorted list of genes present in every sample. Each sample is list of gene names possibly duplicate.", "verified": true, "reference_solution": "def science_common_genes(samples):\n    \"\"\"Return a sorted list of gene names that appear in every sample.\n    Each sample is a list (possibly containing duplicates).\n    If the input list of samples is empty, or if no genes are common to all\n    samples, an empty list is returned.\n    \"\"\"\n    # No samples provided\n    if not samples:\n        return []\n\n    # Start with genes from the first sample (as a set to remove duplicates)\n    common = set(samples[0])\n\n    # Intersect with the genes present in every other sample\n    for sample in samples[1:]:\n        common &= set(sample)\n        # Early exit: if intersection becomes empty, no need to continue\n        if not common:\n            return []\n\n    return sorted(common)", "reference_tests": [{"type": "basic", "inputs": [[["BRCA1", "TP53", "EGFR"], ["EGFR", "TP53", "MTOR"], ["TP53", "EGFR", "BRCA1"]]], "output": ["EGFR", "TP53"]}, {"type": "basic", "inputs": [[["A", "B", "A"], ["B", "B", "C", "A"], ["A", "B"]]], "output": ["A", "B"]}, {"type": "edge_case", "inputs": [[["A", "B"], ["C", "D"]]], "output": []}, {"type": "edge_case", "inputs": [[]], "output": []}, {"type": "edge_case", "inputs": [[[], ["A", "B"]]], "output": []}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Goal is to list genes that appear in every provided sample"}, {"shard_id": 2, "shard": "Input is many samples each being a list of gene names possibly repeated"}, {"shard_id": 3, "shard": "Output should be the shared gene names sorted alphabetically with no duplicates"}, {"shard_id": 4, "shard": "If no samples or no overlap then output is an empty list"}]}}, {"problem_id": 32, "category": "bitwise", "name": "toggle_experiment_flags", "domain": "science", "description": "Given integer flag state and list of bit positions, toggle each bit. Bits are 0-indexed from right.", "verified": true, "reference_solution": "def toggle_experiment_flags(flag_state, positions):\n    \"\"\"Toggle bits at the given positions in flag_state.\n\n    Args:\n        flag_state (int): The original integer containing flag bits.\n        positions (list[int]): List of 0-indexed bit positions to toggle.\n\n    Returns:\n        int: The resulting integer after toggling the specified bits.\n    \"\"\"\n    for pos in positions:\n        flag_state ^= 1 << pos  # XOR with a mask flips the bit at 'pos'\n    return flag_state", "reference_tests": [{"type": "basic", "inputs": [5, [0]], "output": 4}, {"type": "basic", "inputs": [0, [1, 3]], "output": 10}, {"type": "edge_case", "inputs": [6, [1, 2, 1]], "output": 2}, {"type": "edge_case", "inputs": [15, []], "output": 15}, {"type": "edge_case", "inputs": [1, [10]], "output": 1025}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need to change specific bits of given flag integer"}, {"shard_id": 2, "shard": "Provide list of zero indexed positions from least significant side"}, {"shard_id": 3, "shard": "Flip bit at each listed spot then output resulting integer value"}, {"shard_id": 4, "shard": "When list empty return original else apply bit toggles to all"}]}}, {"problem_id": 33, "category": "simulation", "name": "population_decay", "domain": "science", "description": "Simulate population P with decay rate r% per year for n years, rounding to nearest integer each year. Return list including initial population.", "verified": true, "reference_solution": "def population_decay(P: int, r: float, n: int):\n    \"\"\"Simulate population decay.\n\n    Parameters:\n    P (int): initial population\n    r (float): decay rate in percent per year\n    n (int): number of years to simulate\n\n    Returns:\n    list: populations from year 0 through year n (inclusive), each rounded to the nearest integer after each year's decay.\n    \"\"\"\n    # Validate inputs minimally\n    if n < 0:\n        raise ValueError(\"Number of years 'n' must be non-negative\")\n\n    populations = [int(P)]  # ensure starting value is an integer\n    current = P\n    for _ in range(n):\n        current = round(current * (1 - r / 100.0))\n        populations.append(int(current))\n    return populations", "reference_tests": [{"type": "basic", "inputs": [1000, 10, 3], "output": [1000, 900, 810, 729]}, {"type": "basic", "inputs": [500, 20, 2], "output": [500, 400, 320]}, {"type": "edge_case", "inputs": [123, 5, 0], "output": [123]}, {"type": "edge_case", "inputs": [1000, 0, 4], "output": [1000, 1000, 1000, 1000, 1000]}, {"type": "edge_case", "inputs": [5, 50, 1], "output": [5, 2]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Model yearly shrinking population and list each years count"}, {"shard_id": 2, "shard": "Input start number P rate r percent years n"}, {"shard_id": 3, "shard": "Each year multiply by one minus r percent round nearest whole"}, {"shard_id": 4, "shard": "Return list from year zero through n for example 1000 10 3 gives 1000 900 810 729"}]}}, {"problem_id": 34, "category": "recursion", "name": "chemical_chain_rewrite", "domain": "science", "description": "Recursively replace every occurrence of pattern 'AB' with 'BA' in a molecule string until no more replacements possible; return final string.", "verified": true, "reference_solution": "def chemical_chain_rewrite(molecule: str) -> str:\n    \"\"\"\n    Recursively replace every occurrence of the pattern 'AB' with 'BA' in the\n    provided molecule string until no further replacements are possible.\n\n    Parameters\n    ----------\n    molecule : str\n        The input molecule string consisting of characters (assumed to be only\n        'A' and 'B', though the algorithm will work with any characters as long\n        as the target pattern is 'AB').\n\n    Returns\n    -------\n    str\n        The molecule string after all possible 'AB' -> 'BA' rewrites have been\n        applied.\n    \"\"\"\n    # Continue rewriting while the pattern exists in the molecule\n    while 'AB' in molecule:\n        molecule = molecule.replace('AB', 'BA')  # single pass replacement\n    return molecule\n", "reference_tests": [{"type": "basic", "inputs": ["AB"], "output": "BA"}, {"type": "basic", "inputs": ["AAB"], "output": "BAA"}, {"type": "basic", "inputs": ["ABAB"], "output": "BBAA"}, {"type": "edge_case", "inputs": [""], "output": ""}, {"type": "edge_case", "inputs": ["ABBA"], "output": "BBAA"}, {"type": "edge_case", "inputs": ["AAA"], "output": "AAA"}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Goal change every AB to BA within a molecule string"}, {"shard_id": 2, "shard": "Keep repeating the swap until no more AB found"}, {"shard_id": 3, "shard": "Function takes one string and returns its final version"}, {"shard_id": 4, "shard": "Example input ABAB should finally become BBAA"}]}}, {"problem_id": 35, "category": "counting", "name": "count_prime_measurements", "domain": "science", "description": "Count how many measurement integers are prime. Input size \u226410 000.", "verified": true, "reference_solution": "def count_prime_measurements(measurements):\n    \"\"\"Return the count of prime numbers inside the iterable *measurements*.\n\n    A prime number is an integer greater than 1 that has no positive divisors other\n    than 1 and itself. Negative numbers, 0 and 1 are not considered prime.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True  # 2 and 3 are prime\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        # Check from 5 to sqrt(n) skipping even numbers and multiples of 3.\n        i = 5\n        step = 2  # alternates 2, 4 (i.e., 6k \u00b1 1 checks)\n        while i * i <= n:\n            if n % i == 0:\n                return False\n            i += step\n            step = 6 - step  # toggles between adding 2 and 4\n        return True\n\n    return sum(1 for value in measurements if is_prime(value))", "reference_tests": [{"type": "basic", "inputs": [[2, 3, 4, 5, 6, 7]], "output": 4}, {"type": "basic", "inputs": [[10, 11, 12, 13, 14, 15]], "output": 2}, {"type": "edge_case", "inputs": [[-3, -2, 0, 1]], "output": 0}, {"type": "edge_case", "inputs": [[]], "output": 0}, {"type": "edge_case", "inputs": [[99991, 99989, 100000]], "output": 2}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Count prime valued entries in a provided measurement list"}, {"shard_id": 2, "shard": "Input is at most ten thousand whole numbers"}, {"shard_id": 3, "shard": "Output one integer that reports how many are prime"}, {"shard_id": 4, "shard": "Zero one and negatives never qualify as prime here"}]}}, {"problem_id": 36, "category": "greedy", "name": "minimum_truck_loads", "domain": "logistics", "description": "Given package weights and truck capacity, return minimum number of trucks using first-fit decreasing algorithm.", "verified": true, "reference_solution": "def minimum_truck_loads(weights, capacity):\n    \"\"\"Return the minimum number of trucks required to ship all packages\n    using the First-Fit Decreasing (FFD) heuristic.\n\n    Parameters\n    ----------\n    weights : list[int]\n        A list of positive integers representing package weights.\n    capacity : int\n        The maximum weight a single truck can carry.\n\n    Returns\n    -------\n    int\n        The number of trucks used by the FFD algorithm.\n    \"\"\"\n    # Edge case: no packages\n    if not weights:\n        return 0\n\n    # Sort packages by non-increasing weight (decreasing)\n    weights_sorted = sorted(weights, reverse=True)\n\n    # Each element stores the remaining capacity of a truck currently in use\n    remaining = []  # type: list[int]\n\n    for w in weights_sorted:\n        # Try to fit the package into the first truck that can take it\n        placed = False\n        for i in range(len(remaining)):\n            if w <= remaining[i]:\n                remaining[i] -= w\n                placed = True\n                break\n\n        # If it doesn't fit in any existing truck, open a new one\n        if not placed:\n            if w > capacity:\n                raise ValueError(\"Package weight exceeds truck capacity.\")\n            remaining.append(capacity - w)\n\n    # Number of trucks is the length of remaining list\n    return len(remaining)\n", "reference_tests": [{"type": "basic", "inputs": [[4, 8, 1, 4, 2, 1], 10], "output": 2}, {"type": "basic", "inputs": [[9, 8, 2, 2, 5], 10], "output": 3}, {"type": "edge_case", "inputs": [[], 15], "output": 0}, {"type": "edge_case", "inputs": [[5, 5, 5], 5], "output": 3}, {"type": "edge_case", "inputs": [[1, 1, 1], 10], "output": 1}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Find trucks needed for shipping given weights and capacity"}, {"shard_id": 2, "shard": "Sort packages largest first then place into earliest truck that fits"}, {"shard_id": 3, "shard": "Input is many positive weights and one capacity output is truck total"}, {"shard_id": 4, "shard": "Open new truck when none fit and return zero when no packages"}]}}, {"problem_id": 37, "category": "formatting", "name": "pad_tracking_numbers", "domain": "logistics", "description": "Ensure each tracking number has exactly 12 digits by left-padding with zeros. Return amended list.", "verified": true, "reference_solution": "def pad_tracking_numbers(tracking_numbers):\n    \"\"\"Return list where every tracking number is a 12-digit string padded with leading zeros.\n    Accepts a list of integers or strings representing non-negative tracking numbers.\n    \"\"\"\n    padded = []\n    for tn in tracking_numbers:\n        # Convert to string safely\n        tn_str = str(tn)\n        # If it already has 12+ characters, keep as is; otherwise pad on the left\n        if len(tn_str) < 12:\n            tn_str = tn_str.zfill(12)\n        padded.append(tn_str)\n    return padded", "reference_tests": [{"type": "basic", "inputs": [["12345", "987654321"]], "output": ["000000012345", "000987654321"]}, {"type": "basic", "inputs": [[123, 456789012345]], "output": ["000000000123", "456789012345"]}, {"type": "edge_case", "inputs": [[]], "output": []}, {"type": "edge_case", "inputs": [["000123456789"]], "output": ["000123456789"]}, {"type": "edge_case", "inputs": [[0]], "output": ["000000000000"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Goal make every parcel number show twelve digits no matter input size"}, {"shard_id": 2, "shard": "Input list holds numbers or digit strings never negative values"}, {"shard_id": 3, "shard": "Need to add zeroes on the left until length becomes twelve"}, {"shard_id": 4, "shard": "So 12345 turns into 000000012345 and empty list stays empty"}]}}, {"problem_id": 38, "category": "validation", "name": "validate_container_code", "domain": "logistics", "description": "Check container code matches pattern four letters, seven digits. Also verify letters exclude I,O,Q. Return bool.", "verified": true, "reference_solution": "def validate_container_code(code: str) -> bool:\n    \"\"\"Validate a container code: 4 letters (A-Z, excluding I, O, Q),\n    followed by 7 digits. Return True if valid, else False.\"\"\"\n    # Total length must be exactly 11 characters\n    if len(code) != 11:\n        return False\n\n    letters, digits = code[:4], code[4:]\n\n    # First 4 must all be uppercase alphabetic characters and not I, O, Q\n    if not letters.isalpha() or not letters.isupper():\n        return False\n    if any(ch in \"IOQ\" for ch in letters):\n        return False\n\n    # Last 7 must all be digits\n    if not digits.isdigit():\n        return False\n\n    return True", "reference_tests": [{"type": "basic", "inputs": ["MSCU1234567"], "output": true}, {"type": "basic", "inputs": ["MSIU1234567"], "output": false}, {"type": "basic", "inputs": ["ABCD12345A7"], "output": false}, {"type": "edge_case", "inputs": ["ABcD1234567"], "output": false}, {"type": "edge_case", "inputs": ["ABCD123456"], "output": false}, {"type": "edge_case", "inputs": ["ABCD12345678"], "output": false}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Verify a shipping container identifier follows required format"}, {"shard_id": 2, "shard": "It starts with four uppercase letters none may be I O or Q"}, {"shard_id": 3, "shard": "Those letters must be followed by seven digits zero through nine"}, {"shard_id": 4, "shard": "String length must be eleven overall result is boolean valid or not"}]}}, {"problem_id": 39, "category": "statistics", "name": "average_delivery_delay", "domain": "logistics", "description": "Given list of (expected, actual) datetime strings, compute average delay in days rounded two decimals; positives indicate late delivery.", "sample_type": "code_synthetic"}, {"problem_id": 40, "category": "filtering", "name": "filter_heavy_packages", "domain": "logistics", "description": "Return package IDs whose weight exceeds provided threshold and whose destination isn't on exclusion list.", "verified": true, "reference_solution": "def filter_heavy_packages(packages, weight_threshold, exclusion_destinations):\n    \"\"\"Return a list of package IDs whose weight exceeds the given threshold and whose\n    destination is not present in the exclusion list.\n\n    Args:\n        packages (list[dict]): Each dict must have keys 'id', 'weight', 'destination'.\n        weight_threshold (int | float): The minimum weight a package must exceed.\n        exclusion_destinations (list[str]): Destinations to exclude.\n\n    Returns:\n        list: IDs of packages satisfying the criteria, in original order.\n    \"\"\"\n    # Convert exclusions to a set for O(1) look-ups.\n    exclusion_set = set(exclusion_destinations)\n\n    # Filter and collect IDs preserving input order.\n    result_ids = [pkg['id'] for pkg in packages\n                  if pkg.get('weight', 0) > weight_threshold and\n                  pkg.get('destination') not in exclusion_set]\n    return result_ids\n", "reference_tests": [{"type": "basic", "inputs": [[{"id": 1, "weight": 15, "destination": "NY"}, {"id": 2, "weight": 5, "destination": "CA"}, {"id": 3, "weight": 20, "destination": "TX"}], 10, ["CA"]], "output": [1, 3]}, {"type": "basic", "inputs": [[{"id": "A", "weight": 50, "destination": "LA"}, {"id": "B", "weight": 40, "destination": "NY"}, {"id": "C", "weight": 70, "destination": "LA"}], 45, ["NY"]], "output": ["A", "C"]}, {"type": "edge_case", "inputs": [[], 30, ["LA"]], "output": []}, {"type": "edge_case", "inputs": [[{"id": 10, "weight": 5, "destination": "SF"}, {"id": 11, "weight": 9, "destination": "LA"}], 10, []], "output": []}, {"type": "edge_case", "inputs": [[{"id": "X", "weight": 100, "destination": "NK"}, {"id": "Y", "weight": 100, "destination": "NK"}], 50, ["NK"]], "output": []}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need IDs of big packages avoiding banned places"}, {"shard_id": 2, "shard": "Input list has items id weight destination"}, {"shard_id": 3, "shard": "Keep those heavier than given limit"}, {"shard_id": 4, "shard": "Skip if destination matches any exclusion name"}]}}, {"problem_id": 41, "category": "sorting", "name": "sort_products_by_margin", "domain": "ecommerce", "description": "Given list of dicts with cost and price, sort products by descending profit margin percentage. Break ties by ascending product id.", "verified": true, "reference_solution": "def sort_products_by_margin(products):\n    \"\"\"Sort a list of product dictionaries by descending profit margin percentage.\n\n    Each product dict is expected to have at least these keys:\n        - 'id': a value that can be compared (typically an int)\n        - 'cost': numeric cost (>=0)\n        - 'price': numeric selling price\n\n    The profit margin percentage is computed as (price - cost) / cost.\n    Products are ordered primarily by descending margin, and secondarily by\n    ascending id in case of ties.\n    The function returns a new sorted list and leaves the original untouched.\n    \"\"\"\n    def margin(product):\n        cost = product.get('cost', 0)\n        price = product.get('price', 0)\n        if cost == 0:\n            # Define infinite margin for zero cost but higher price, otherwise 0\n            return float('inf') if price > 0 else 0.0\n        return (price - cost) / cost\n\n    # Sort by (-margin, id) so that larger margin comes first and id ascending breaks ties\n    return sorted(products, key=lambda p: (-margin(p), p.get('id')))\n", "reference_tests": [{"type": "basic", "inputs": [[{"id": 1, "cost": 50, "price": 100}, {"id": 2, "cost": 30, "price": 60}, {"id": 3, "cost": 20, "price": 25}]], "output": [{"id": 1, "cost": 50, "price": 100}, {"id": 2, "cost": 30, "price": 60}, {"id": 3, "cost": 20, "price": 25}]}, {"type": "basic", "inputs": [[{"id": 10, "cost": 80, "price": 120}, {"id": 11, "cost": 40, "price": 60}, {"id": 12, "cost": 50, "price": 100}]], "output": [{"id": 12, "cost": 50, "price": 100}, {"id": 10, "cost": 80, "price": 120}, {"id": 11, "cost": 40, "price": 60}]}, {"type": "edge_case", "inputs": [[{"id": 4, "cost": 20, "price": 30}, {"id": 5, "cost": 40, "price": 60}, {"id": 6, "cost": 50, "price": 60}]], "output": [{"id": 4, "cost": 20, "price": 30}, {"id": 5, "cost": 40, "price": 60}, {"id": 6, "cost": 50, "price": 60}]}, {"type": "edge_case", "inputs": [[{"id": 99, "cost": 10, "price": 15}]], "output": [{"id": 99, "cost": 10, "price": 15}]}, {"type": "edge_case", "inputs": [[]], "output": []}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Goal sort a product list by best profit percentage first"}, {"shard_id": 2, "shard": "Each product record has id cost price all numeric values"}, {"shard_id": 3, "shard": "Profit percent equals price minus cost divided by cost larger value comes earlier"}, {"shard_id": 4, "shard": "If profits equal choose smaller id otherwise keep order produce new sorted list"}]}}, {"problem_id": 42, "category": "string_manipulation", "name": "truncate_product_titles", "domain": "ecommerce", "description": "Shorten titles longer than 60 characters without cutting words; append '...' if truncated. Return updated titles.", "sample_type": "code_synthetic"}, {"problem_id": 43, "category": "math", "name": "calculate_cart_total", "domain": "ecommerce", "description": "Sum prices with quantities, apply percentage discount d, round to 2 decimals, and return total.", "verified": true, "reference_solution": "def calculate_cart_total(prices, quantities, discount):\n    \"\"\"Calculate the total cost of a shopping cart.\n\n    Args:\n        prices (list[float | int]): Unit prices of the items.\n        quantities (list[int | float]): Corresponding quantities for each item.\n        discount (float | int): Percentage discount to apply (0-100).\n\n    Returns:\n        float: Total cost after applying discount, rounded to 2 decimals.\n    \"\"\"\n    # Guard against invalid inputs by treating non-iterables as empty lists\n    if not hasattr(prices, '__iter__'):\n        prices = []\n    if not hasattr(quantities, '__iter__'):\n        quantities = []\n\n    # Work with the overlapping part only to avoid IndexError on mismatched lengths\n    paired_length = min(len(prices), len(quantities))\n\n    subtotal = 0.0\n    for i in range(paired_length):\n        try:\n            subtotal += float(prices[i]) * float(quantities[i])\n        except (ValueError, TypeError):\n            # If conversion fails, treat that line item as 0 cost\n            continue\n\n    # Ensure discount is numeric and between 0 and 100; otherwise clamp\n    try:\n        discount_val = float(discount)\n    except (ValueError, TypeError):\n        discount_val = 0.0\n    discount_val = max(0.0, min(100.0, discount_val))\n\n    total = subtotal * (1 - discount_val / 100.0)\n    return round(total + 1e-9, 2)  # tiny offset to mitigate binary rounding issues\n", "reference_tests": [{"type": "basic", "inputs": [[10, 20, 30], [1, 2, 3], 10], "output": 126.0}, {"type": "basic", "inputs": [[5.5, 3.25], [2, 4], 0], "output": 24.0}, {"type": "edge_case", "inputs": [[100], [1], 100], "output": 0.0}, {"type": "edge_case", "inputs": [[], [], 5], "output": 0.0}, {"type": "edge_case", "inputs": [[10, 20], [1], 50], "output": 5.0}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Find final cost for a cart after discount"}, {"shard_id": 2, "shard": "Multiply every price by matching quantity then sum them"}, {"shard_id": 3, "shard": "Reduce that sum by given percent discount in range zero to hundred"}, {"shard_id": 4, "shard": "Output rounded to two decimal places using inputs prices list quantities list discount"}]}}, {"problem_id": 44, "category": "geometry", "name": "gift_box_diagonal", "domain": "ecommerce", "description": "Compute internal diagonal of rectangular box given length, width, height. Return float rounded three decimals.", "verified": true, "reference_solution": "import math\ndef gift_box_diagonal(length, width, height):\n    \"\"\"Return the internal diagonal of a rectangular box rounded to three decimals.\"\"\"\n    diagonal = math.sqrt(length ** 2 + width ** 2 + height ** 2)\n    return round(diagonal, 3)\n", "reference_tests": [{"type": "basic", "inputs": [1, 2, 2], "output": 3.0}, {"type": "basic", "inputs": [3, 4, 12], "output": 13.0}, {"type": "edge_case", "inputs": [1.5, 2.5, 3.5], "output": 4.555}, {"type": "edge_case", "inputs": [0, 0, 0], "output": 0.0}, {"type": "edge_case", "inputs": [0.333, 0.444, 0.555], "output": 0.785}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Find the internal diagonal inside a rectangular prism shaped gift box"}, {"shard_id": 2, "shard": "Inputs are three numbers giving length width and height of the box"}, {"shard_id": 3, "shard": "Compute square root of sum of squares of the three numbers"}, {"shard_id": 4, "shard": "Output float rounded to three decimal digits like thirteen point one two three"}]}}, {"problem_id": 45, "category": "list_processing", "name": "batch_orders", "domain": "ecommerce", "description": "Group order ids into batches of at most k where all belong to same country. Preserve original order across batches.", "sample_type": "code_synthetic"}, {"problem_id": 46, "category": "combinatorics", "name": "possible_anagrams_count", "domain": "linguistics", "description": "Count distinct anagrams for word allowing repeated letters, result modulo 1 000 000 007.", "verified": true, "reference_solution": "def possible_anagrams_count(word):\n    MOD = 1_000_000_007\n    n = len(word)\n    # Precompute factorials up to n\n    fact = [1]*(n+1)\n    for i in range(2, n+1):\n        fact[i] = (fact[i-1]*i) % MOD\n    # Count frequency of each character\n    from collections import Counter\n    freq = Counter(word)\n    # Compute denominator as product of factorials of frequencies\n    denom = 1\n    for c in freq.values():\n        denom = (denom * fact[c]) % MOD\n    # Use Fermat's little theorem for modular inverse since MOD is prime\n    inv_denom = pow(denom, MOD-2, MOD)\n    return (fact[n] * inv_denom) % MOD", "reference_tests": [{"type": "basic", "inputs": ["abc"], "output": 6}, {"type": "basic", "inputs": ["aab"], "output": 3}, {"type": "edge_case", "inputs": ["zzzz"], "output": 1}, {"type": "edge_case", "inputs": ["abab"], "output": 6}, {"type": "edge_case", "inputs": [""], "output": 1}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Count all unique reorderings of the input word"}, {"shard_id": 2, "shard": "If letters repeat they shrink the total count"}, {"shard_id": 3, "shard": "Return the count mod 1000000007 positive number"}, {"shard_id": 4, "shard": "Examples empty string gives one and aab gives three"}]}}, {"problem_id": 47, "category": "date_time", "name": "closest_palindrome_date", "domain": "linguistics", "description": "For given YYYY-MM-DD, find nearest future date whose digits read same forward and backward when written YYYYMMDD.", "verified": true, "reference_solution": "def closest_palindrome_date(date_str):\n    \"\"\"Return the closest future date (strictly after the given date) such that\n    the concatenation YYYYMMDD is a palindrome.\n    \n    Args:\n        date_str (str): Date in the format 'YYYY-MM-DD'.\n\n    Returns:\n        str: The next palindrome date in 'YYYY-MM-DD' format.\n    \"\"\"\n    import datetime\n\n    # Parse the incoming date string\n    try:\n        current_date = datetime.datetime.strptime(date_str, \"%Y-%m-%d\").date()\n    except ValueError:\n        raise ValueError(\"Input must be a valid date in YYYY-MM-DD format\")\n\n    # Helper to test palindromicity of a date\n    def is_palindrome(d: datetime.date) -> bool:\n        s = d.strftime(\"%Y%m%d\")\n        return s == s[::-1]\n\n    one_day = datetime.timedelta(days=1)\n    max_date = datetime.date(9999, 12, 31)\n    next_date = current_date + one_day  # must be strictly in the future\n\n    while next_date <= max_date:\n        if is_palindrome(next_date):\n            return next_date.strftime(\"%Y-%m-%d\")\n        next_date += one_day\n\n    # If we exhaust the supported range, signal the problem.\n    raise ValueError(\"No palindrome date exists in supported range after the given date\")\n", "reference_tests": [{"type": "basic", "inputs": ["2021-12-01"], "output": "2021-12-02"}, {"type": "basic", "inputs": ["2021-12-02"], "output": "2030-03-02"}, {"type": "edge_case", "inputs": ["1999-12-31"], "output": "2001-10-02"}, {"type": "edge_case", "inputs": ["2011-11-11"], "output": "2020-02-02"}, {"type": "edge_case", "inputs": ["2001-10-01"], "output": "2001-10-02"}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Find the next calendar day whose digits read the same backward"}, {"shard_id": 2, "shard": "Input arrives as YYYY dash MM dash DD like 2021 dash 12 dash 01"}, {"shard_id": 3, "shard": "Drop the dashes join to YYYYMMDD then test if it mirrors perfectly"}, {"shard_id": 4, "shard": "Return the first such day strictly later than the one supplied"}]}}, {"problem_id": 48, "category": "parsing", "name": "ipa_symbol_extractor", "domain": "linguistics", "description": "Extract and return list of unique IPA symbols appearing between slashes / / in text, preserving appearance order.", "verified": true, "reference_solution": "def ipa_symbol_extractor(text):\n    \"\"\"Extract unique IPA symbols that appear between slashes (/ ... /) in the\n    given text, preserving their first\u2010appearance order.\n\n    Parameters\n    ----------\n    text : str\n        Input text possibly containing IPA transcriptions wrapped in slashes.\n\n    Returns\n    -------\n    list[str]\n        List of unique IPA symbols in order of first appearance.\n    \"\"\"\n    inside = False          # Are we currently inside a pair of slashes?\n    seen = set()            # Fast lookup for symbols we already added\n    symbols = []            # Ordered list of unique symbols to return\n\n    for ch in text:\n        if ch == '/':\n            # Toggle the inside flag when we hit a slash\n            inside = not inside\n            continue\n        if inside:\n            # Skip whitespace inside IPA transcription\n            if ch.isspace():\n                continue\n            if ch not in seen:\n                seen.add(ch)\n                symbols.append(ch)\n\n    return symbols", "reference_tests": [{"type": "basic", "inputs": ["English cat is /k\u00e6t/ and bat is /b\u00e6t/."], "output": ["k", "\u00e6", "t", "b"]}, {"type": "basic", "inputs": ["/p\u026an/ to /p\u026a\u014b/ vs /p\u026an/"], "output": ["p", "\u026a", "n", "\u014b"]}, {"type": "edge_case", "inputs": ["Pronounce / t \u0283 / or /d\u0292 /"], "output": ["t", "\u0283", "d", "\u0292"]}, {"type": "edge_case", "inputs": ["Start /s p"], "output": ["s", "p"]}, {"type": "edge_case", "inputs": [""], "output": []}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need to pull IPA characters from text"}, {"shard_id": 2, "shard": "Consider only stuff that sits between two forward slashes"}, {"shard_id": 3, "shard": "Keep first time each symbol appears and remember that order"}, {"shard_id": 4, "shard": "Skip blanks inside the slashes and output list of those symbols"}]}}, {"problem_id": 49, "category": "searching", "name": "find_word_variant", "domain": "linguistics", "description": "Given sorted list of dictionary words, binary search for word ignoring accents (provided as separate mapping). Return index or -1.", "verified": true, "reference_solution": "def find_word_variant(words, target, mapping):\n    \"\"\"Binary-search `words` (sorted under accent-insensitive order) for a word\n    that matches `target` once every character is normalised with *mapping*.\n\n    Parameters\n    ----------\n    words : list[str]\n        Sorted list of dictionary words (accented characters allowed).\n    target : str\n        Word being searched for (typically without accents).\n    mapping : dict[str, str]\n        Maps accented characters to their unaccented counterparts.\n\n    Returns\n    -------\n    int\n        Index of a matching word in *words* or -1 when no match exists.\n    \"\"\"\n\n    # Helper that removes accents using the provided mapping.\n    def _normalize(s: str) -> str:\n        # Turn every char into its mapped replacement (or itself).\n        return ''.join(mapping.get(ch, ch) for ch in s).lower()\n\n    target_norm = _normalize(target)\n    lo, hi = 0, len(words) - 1\n\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        mid_norm = _normalize(words[mid])\n\n        if mid_norm == target_norm:\n            return mid  # found exact accent-insensitive match\n        if mid_norm < target_norm:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1\n", "reference_tests": [{"type": "basic", "inputs": [["caf\u00e9", "jalape\u00f1o", "pi\u00f1ata", "r\u00e9sum\u00e9"], "resume", {"\u00e9": "e", "\u00f1": "n", "\u00ed": "i", "\u00e1": "a", "\u00f3": "o"}], "output": 3}, {"type": "basic", "inputs": [["a\u00f1o", "\u00e1rbol", "ni\u00f1o"], "arbol", {"\u00f1": "n", "\u00e1": "a"}], "output": 1}, {"type": "edge_case", "inputs": [["caf\u00e9", "jalape\u00f1o", "pi\u00f1ata", "r\u00e9sum\u00e9"], "cafeine", {"\u00e9": "e", "\u00f1": "n", "\u00ed": "i", "\u00e1": "a", "\u00f3": "o"}], "output": -1}, {"type": "edge_case", "inputs": [[], "anything", {"\u00e9": "e"}], "output": -1}, {"type": "basic", "inputs": [["\u00e9l", "ella", "ellos"], "el", {"\u00e9": "e"}], "output": 0}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Search alphabetized word list while ignoring diacritical marks"}, {"shard_id": 2, "shard": "Convert letters via given accent map before equality check"}, {"shard_id": 3, "shard": "Leverage binary search since list already sorted under normalized order"}, {"shard_id": 4, "shard": "Return index if match exists otherwise minus one"}]}}, {"problem_id": 50, "category": "hashing", "name": "phonetic_hash", "domain": "linguistics", "description": "Implement simplified Soundex: return 4-character code consisting of first letter capitalized plus three digits per mapping, zeros padded.", "verified": true, "reference_solution": "def phonetic_hash(word: str) -> str:\n    \"\"\"Return the 4\u2013character (letter+3 digits) simplified Soundex code of the input word.\n    The rules implemented correspond to the traditional Soundex algorithm (American\n    Soundex):\n    1. Keep the first letter (upper-cased).\n    2. Map the remaining letters to digits with the groups:\n       B,F,P,V -> 1 ;  C,G,J,K,Q,S,X,Z -> 2 ;  D,T -> 3 ;  L -> 4 ;  M,N -> 5 ;  R -> 6\n    3. Adjacent letters that map to the same digit are coded once. Letters H or W\n       are ignored but do NOT break adjacency; vowels (A,E,I,O,U,Y) break adjacency.\n    4. Return the first letter followed by the first three significant digits,\n       padding with zeros where necessary.\n    \"\"\"\n    if not word:\n        return \"0000\"  # empty input safeguard\n\n    # Mapping from consonants to Soundex digits\n    mapping = {\n        **{c: \"1\" for c in \"BFPV\"},\n        **{c: \"2\" for c in \"CGJKQSXZ\"},\n        **{c: \"3\" for c in \"DT\"},\n        \"L\": \"4\",\n        **{c: \"5\" for c in \"MN\"},\n        \"R\": \"6\",\n    }\n\n    word_upper = word.upper()\n    first_letter = word_upper[0]\n    code_digits = []\n\n    # Previous digit (start with the code of the first letter if any)\n    prev_digit = mapping.get(first_letter, \"\")\n\n    for ch in word_upper[1:]:\n        digit = mapping.get(ch, \"\")  # empty string if ch is a vowel/H/W/Y/etc.\n\n        if digit:\n            # Consonant with a mapping\n            if digit != prev_digit:\n                code_digits.append(digit)\n                prev_digit = digit\n                if len(code_digits) == 3:\n                    break\n        else:\n            # ch is a vowel or H/W/Y.  Vowels reset adjacency; H/W keep it.\n            if ch in \"AEIOUY\":\n                prev_digit = \"\"\n            # For H or W we keep prev_digit unchanged (considered adjacent)\n            continue\n\n    # Pad with zeros if necessary and build the final code\n    return first_letter + \"\".join(code_digits).ljust(3, \"0\")\n", "reference_tests": [{"type": "basic", "inputs": ["Robert"], "output": "R163"}, {"type": "basic", "inputs": ["Rupert"], "output": "R163"}, {"type": "basic", "inputs": ["Rubin"], "output": "R150"}, {"type": "edge_case", "inputs": ["Ashcraft"], "output": "A261"}, {"type": "edge_case", "inputs": ["Pfister"], "output": "P236"}, {"type": "edge_case", "inputs": ["Tymczak"], "output": "T522"}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need a simple Soundex generator making letter plus three digits total length four"}, {"shard_id": 2, "shard": "Take one word return code like R163 uppercase letter then three digits zero padded"}, {"shard_id": 3, "shard": "Digits come from consonant groups BFPV one CGJKQSXZ two DT three L four MN five R six"}, {"shard_id": 4, "shard": "Skip repeating adjacent codes vowels reset H and W ignored finalize first three digits pad zeros"}]}}, {"problem_id": 51, "category": "set_operations", "name": "common_visible_stars", "domain": "astronomy", "description": "Return sorted IDs of stars simultaneously visible from all given observatories' visibility sets.", "verified": true, "reference_solution": "def common_visible_stars(observatories):\n    \"\"\"Return a sorted list of star IDs that are visible from every observatory.\n\n    Parameters\n    ----------\n    observatories : list[Iterable]\n        A list where each element is an iterable (e.g., list, set, tuple) of\n        star IDs visible from a particular observatory.\n\n    Returns\n    -------\n    list\n        Sorted list of star IDs that are common to all observatories. If the\n        input list is empty, or if there is no common star, an empty list is\n        returned.\n    \"\"\"\n    # If there are no observatories provided, return empty list.\n    if not observatories:\n        return []\n\n    # Initialize intersection with the first observatory's stars\n    common_stars = set(observatories[0])\n\n    # Intersect with the rest of the observatories\n    for stars in observatories[1:]:\n        common_stars &= set(stars)\n        # Early exit if intersection becomes empty\n        if not common_stars:\n            return []\n\n    return sorted(common_stars)\n", "reference_tests": [{"type": "basic", "inputs": [[[1, 2, 3], [2, 3, 4], [2, 5]]], "output": [2]}, {"type": "basic", "inputs": [[[10, 20, 30], [30, 20, 10]]], "output": [10, 20, 30]}, {"type": "edge_case", "inputs": [[]], "output": []}, {"type": "edge_case", "inputs": [[[5, 3, 1]]], "output": [1, 3, 5]}, {"type": "edge_case", "inputs": [[[1, 2], [3, 4]]], "output": []}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Goal get the stars visible from all provided observatory records"}, {"shard_id": 2, "shard": "Input many iterables each containing integer star ids"}, {"shard_id": 3, "shard": "Output sorted ascending list of ids found in every iterable"}, {"shard_id": 4, "shard": "Return empty when input empty or no shared stars exist"}]}}, {"problem_id": 52, "category": "bitwise", "name": "encode_constellation_pattern", "domain": "astronomy", "description": "Represent constellation of up to 16 stars as 16-bit integer where bit i is 1 if star i present. Input list may contain duplicates.", "verified": true, "reference_solution": "def encode_constellation_pattern(stars):\n    \"\"\"Encode a list of star indices (0-15) into a 16-bit integer.\n    Each bit i (0 being least-significant) is set to 1 if star i is present.\n    Duplicates in the input list do not affect the result.\n    \"\"\"\n    pattern = 0\n    for s in stars:\n        # assume valid indices 0-15 as per the problem description\n        pattern |= 1 << s\n    return pattern", "reference_tests": [{"type": "basic", "inputs": [[0, 1, 2]], "output": 7}, {"type": "basic", "inputs": [[3, 3, 3]], "output": 8}, {"type": "edge_case", "inputs": [[]], "output": 0}, {"type": "edge_case", "inputs": [[0, 2, 4, 6, 8, 10, 12, 14]], "output": 21845}, {"type": "edge_case", "inputs": [[15]], "output": 32768}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Convert a list of star spots into a single pattern number"}, {"shard_id": 2, "shard": "Only slots zero through fifteen matter any repeats should be ignored"}, {"shard_id": 3, "shard": "For each slot set that bit in a sixteen bit unsigned answer"}, {"shard_id": 4, "shard": "Example slots zero one two together would yield the value seven"}]}}, {"problem_id": 53, "category": "simulation", "name": "meteor_shower_sim", "domain": "astronomy", "description": "Given hourly rates, simulate cumulative meteors over period using random.seed(0) and Poisson assumption via random.poisson not available; instead approximate by rounding rate*random.random().", "verified": true, "reference_solution": "import random\n\ndef meteor_shower_sim(rates):\n    \"\"\"\n    Simulate a meteor shower given hourly expected rates.\n\n    Parameters\n    ----------\n    rates : list of int/float\n        Expected number of meteors per each hour.\n\n    Returns\n    -------\n    list of int\n        Cumulative number of meteors observed up to (and including) each hour.\n\n    Notes\n    -----\n    The Poisson-distributed number of meteors for each hour is approximated by\n    rounding the product of the hourly rate and `random.random()`.\n    A fixed seed (0) is set on every call so that the function is deterministic\n    for the same input.\n    \"\"\"\n    # Ensure deterministic results for the same input\n    random.seed(0)\n\n    cumulative = []\n    total = 0\n    for rate in rates:\n        # Approximate Poisson draw\n        count = round(rate * random.random())\n        total += count\n        cumulative.append(total)\n    return cumulative\n", "reference_tests": [{"type": "basic", "inputs": [[10, 10, 10]], "output": [8, 16, 20]}, {"type": "basic", "inputs": [[1, 2, 3]], "output": [1, 3, 4]}, {"type": "edge_case", "inputs": [[]], "output": []}, {"type": "edge_case", "inputs": [[0, 0, 0]], "output": [0, 0, 0]}, {"type": "basic", "inputs": [[5.5, 2.2]], "output": [5, 7]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Simulate meteor shower counts from list of hourly expected rates"}, {"shard_id": 2, "shard": "Use python random module with seed zero for repeatable results"}, {"shard_id": 3, "shard": "Draw each hour by rounding rate times random dot random without Poisson"}, {"shard_id": 4, "shard": "Return running cumulative totals list same length handling empty or zero rates"}]}}, {"problem_id": 54, "category": "recursion", "name": "binary_star_orbit_steps", "domain": "astronomy", "description": "Compute nth Fibonacci-like distance sequence where f(0)=a,f(1)=b, f(n)=f(n-1)+f(n-2). Return list up to n inclusive.", "verified": true, "reference_solution": "def binary_star_orbit_steps(a, b, n):\n    \"\"\"Return the Fibonacci-like distance sequence up to n (inclusive).\n\n    Parameters\n    ----------\n    a : int or float\n        The distance at step 0.\n    b : int or float\n        The distance at step 1.\n    n : int\n        The index up to which the sequence is generated (inclusive).\n\n    Returns\n    -------\n    list\n        A list containing the sequence f(0) .. f(n).\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    # Handle n == 0 separately\n    if n == 0:\n        return [a]\n\n    seq = [a, b]\n    for _ in range(2, n + 1):\n        seq.append(seq[-1] + seq[-2])\n    return seq[: n + 1]\n", "reference_tests": [{"type": "basic", "inputs": [1, 1, 5], "output": [1, 1, 2, 3, 5, 8]}, {"type": "basic", "inputs": [2, 3, 4], "output": [2, 3, 5, 8, 13]}, {"type": "edge_case", "inputs": [7, 10, 0], "output": [7]}, {"type": "edge_case", "inputs": [0, 0, 3], "output": [0, 0, 0, 0]}, {"type": "edge_case", "inputs": [5, 8, 1], "output": [5, 8]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Build a star distance list akin to Fibonacci up to some index"}, {"shard_id": 2, "shard": "First entry is a second entry is b both given"}, {"shard_id": 3, "shard": "From step two onward use previous two entries summed"}, {"shard_id": 4, "shard": "Finally output list containing every step through n inclusive"}]}}, {"problem_id": 55, "category": "counting", "name": "count_eclipses_in_range", "domain": "astronomy", "description": "Count how many eclipse dates in sorted list fall within inclusive start and end dates.", "verified": true, "reference_solution": "from bisect import bisect_left, bisect_right\n\ndef count_eclipses_in_range(eclipse_dates, start_date, end_date):\n    \"\"\"Count how many eclipse dates fall within the inclusive range [start_date, end_date].\n\n    Parameters\n    ----------\n    eclipse_dates : list[str]\n        A list of ISO-formatted (YYYY-MM-DD) eclipse dates in ascending order.\n    start_date : str\n        The inclusive start date of the range in ISO format.\n    end_date : str\n        The inclusive end date of the range in ISO format.\n\n    Returns\n    -------\n    int\n        The number of eclipse dates that lie within the given range (inclusive).\n    \"\"\"\n    # If range is invalid, return 0 immediately\n    if start_date > end_date:\n        return 0\n\n    # Find the first index >= start_date\n    left = bisect_left(eclipse_dates, start_date)\n    # Find the first index > end_date\n    right = bisect_right(eclipse_dates, end_date)\n    return max(0, right - left)\n", "reference_tests": [{"type": "basic", "inputs": [["2020-06-21", "2020-12-14", "2021-06-10", "2021-12-04", "2022-04-30"], "2020-01-01", "2020-12-31"], "output": 2}, {"type": "basic", "inputs": [["2020-06-21", "2020-12-14", "2021-06-10", "2021-12-04", "2022-04-30"], "2019-01-01", "2019-12-31"], "output": 0}, {"type": "edge_case", "inputs": [["2020-06-21", "2020-12-14", "2021-06-10", "2021-12-04", "2022-04-30"], "2020-06-21", "2022-04-30"], "output": 5}, {"type": "edge_case", "inputs": [[], "2020-01-01", "2022-12-31"], "output": 0}, {"type": "edge_case", "inputs": [["2020-06-21", "2021-06-10"], "2021-07-01", "2021-01-01"], "output": 0}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Count eclipse events lying inside an inclusive date range"}, {"shard_id": 2, "shard": "Input one sorted ISO date list and two boundary date strings"}, {"shard_id": 3, "shard": "Include dates exactly equal to start or end when counting"}, {"shard_id": 4, "shard": "Return zero for empty list or when start comes after end"}]}}, {"problem_id": 56, "category": "greedy", "name": "team_selection_budget", "domain": "sports", "description": "Pick maximum players without exceeding budget, players have cost and skill. Sort by lowest cost/skill ratio greedily.", "verified": false, "sample_type": "code_synthetic"}, {"problem_id": 57, "category": "formatting", "name": "scoreboard_string", "domain": "sports", "description": "Format list of (team,score) into 'TeamA 3-1 TeamB' style string where higher score listed first.", "sample_type": "code_synthetic"}, {"problem_id": 58, "category": "validation", "name": "validate_badminton_score", "domain": "sports", "description": "Given two scores, ensure reachable under badminton rules (win by 2, cap at 30). Return True/False.", "verified": true, "reference_solution": "def validate_badminton_score(score_a, score_b):\n    \"\"\"Return True if (score_a, score_b) can be a final badminton game score.\n    Standard rally-point rules:\n        * Play to 21, must win by 2.\n        * If the score reaches 20-20, play continues until one side leads by 2\n          except that the game is capped at 30 \u2013 so 30-29 is the latest\n          possible ending.\n    \"\"\"\n    # Both scores must be non-negative integers not exceeding 30.\n    if not (isinstance(score_a, int) and isinstance(score_b, int)):\n        return False\n    if score_a < 0 or score_b < 0 or score_a > 30 or score_b > 30:\n        return False\n\n    # No game can end in a tie.\n    if score_a == score_b:\n        return False\n\n    winner = max(score_a, score_b)\n    loser = min(score_a, score_b)\n\n    # Winner must reach at least 21 points.\n    if winner < 21:\n        return False\n\n    # Case 1: Winner stops at exactly 21.\n    if winner == 21:\n        # Needs at least a 2-point cushion.\n        return loser <= 19\n\n    # Case 2: Winner between 22 and 29 (inclusive).\n    if 22 <= winner <= 29:\n        # Game could only continue beyond 21 if the margin stayed at 1 point\n        # right up until the last rally, so the final margin must be exactly 2.\n        return winner - loser == 2\n\n    # Case 3: Winner hits the cap of 30.\n    if winner == 30:\n        # Only 30-29 is possible (came from 29-29, next point wins).\n        return loser == 29\n\n    # Any other scenario is invalid.\n    return False", "reference_tests": [{"type": "basic", "inputs": [21, 18], "output": true}, {"type": "basic", "inputs": [22, 20], "output": true}, {"type": "basic", "inputs": [21, 20], "output": false}, {"type": "edge_case", "inputs": [30, 29], "output": true}, {"type": "edge_case", "inputs": [30, 28], "output": false}, {"type": "edge_case", "inputs": [25, 17], "output": false}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Check if two badminton scores could be a legal final game"}, {"shard_id": 2, "shard": "Player needs twenty one points and at least a two point lead"}, {"shard_id": 3, "shard": "After twenty all play continues until someone leads or score reaches thirty"}, {"shard_id": 4, "shard": "Give true or false for the pair for example thirty twenty nine is okay"}]}}, {"problem_id": 59, "category": "statistics", "name": "player_moving_average", "domain": "sports", "description": "Compute moving average of last k game points for each player id across chronological records. Return dict id->average.", "sample_type": "code_synthetic"}, {"problem_id": 60, "category": "filtering", "name": "filter_home_games", "domain": "sports", "description": "Return sublist of match dicts where given team appears as home side only.", "verified": true, "reference_solution": "def filter_home_games(matches, team):\n    \"\"\"Return a sub-list of match dictionaries where the provided team\n    appears as the home side.  The function is tolerant of several\n    commonly-used key names for the home team (e.g. 'home', 'homeTeam',\n    'home_team', etc.).\n    \n    Parameters\n    ----------\n    matches : list[dict]\n        A list of match dictionaries.\n    team : str\n        Team name to filter by.\n\n    Returns\n    -------\n    list[dict]\n        Sub-list with only those matches where *team* is the home side.\n    \"\"\"\n    # Accept a few common key spellings for the home side.\n    home_keys = (\n        'home',        # generic / short\n        'homeTeam',    # camelCase\n        'home_team',   # snake_case\n        'homeSide',    # additional variants\n        'home_side'\n    )\n\n    # Build the result using list-comprehension for brevity.\n    return [m for m in matches if any(m.get(k) == team for k in home_keys)]", "reference_tests": [{"type": "basic", "inputs": [[{"home": "TeamA", "away": "TeamB"}, {"home": "TeamC", "away": "TeamA"}, {"home": "TeamA", "away": "TeamD"}], "TeamA"], "output": [{"home": "TeamA", "away": "TeamB"}, {"home": "TeamA", "away": "TeamD"}]}, {"type": "basic", "inputs": [[{"home": "TeamA", "away": "TeamB"}, {"home": "TeamC", "away": "TeamA"}, {"home": "TeamA", "away": "TeamD"}], "TeamB"], "output": []}, {"type": "edge_case", "inputs": [[], "AnyTeam"], "output": []}, {"type": "edge_case", "inputs": [[{"homeTeam": "Lions", "awayTeam": "Tigers"}, {"homeTeam": "Bears", "awayTeam": "Lions"}], "Lions"], "output": [{"homeTeam": "Lions", "awayTeam": "Tigers"}]}, {"type": "edge_case", "inputs": [[{"home": "AAA", "away": "BBB"}, {"home": "AAA", "away": "CCC"}, {"home": "DDD", "away": "AAA"}, {"home": "AAA", "away": "EEE"}], "AAA"], "output": [{"home": "AAA", "away": "BBB"}, {"home": "AAA", "away": "CCC"}, {"home": "AAA", "away": "EEE"}]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Pick out games where a selected club is the host side"}, {"shard_id": 2, "shard": "Input is a list of match dictionaries and a single team name string"}, {"shard_id": 3, "shard": "Look only at fields like home homeTeam home_team to decide hosting"}, {"shard_id": 4, "shard": "If TeamA hosts TeamB that record stays otherwise it is left out"}]}}, {"problem_id": 61, "category": "sorting", "name": "sort_tracks_by_bpm", "domain": "music", "description": "Sort track dicts by BPM ascending, ties broken by descending popularity score.", "verified": true, "reference_solution": "def sort_tracks_by_bpm(tracks):\n    \"\"\"Sort a list of track dictionaries by BPM in ascending order.\n    If multiple tracks have the same BPM, sort those tracks by popularity\n    in descending order.\n\n    Each track dictionary is expected to have at least two keys:\n        - 'bpm': numeric value (int or float)\n        - 'popularity': numeric value (int or float)\n\n    The function returns a new list that is sorted accordingly.\n    \"\"\"\n    # The key uses ascending BPM (x['bpm']) and negative popularity to achieve\n    # descending popularity for tracks with identical BPM.\n    return sorted(tracks, key=lambda x: (x[\"bpm\"], -x[\"popularity\"]))", "reference_tests": [{"type": "basic", "inputs": [[{"title": "Track A", "bpm": 120, "popularity": 80}, {"title": "Track B", "bpm": 110, "popularity": 90}, {"title": "Track C", "bpm": 120, "popularity": 85}]], "output": [{"title": "Track B", "bpm": 110, "popularity": 90}, {"title": "Track C", "bpm": 120, "popularity": 85}, {"title": "Track A", "bpm": 120, "popularity": 80}]}, {"type": "basic", "inputs": [[{"title": "T1", "bpm": 100, "popularity": 50}, {"title": "T2", "bpm": 100, "popularity": 60}]], "output": [{"title": "T2", "bpm": 100, "popularity": 60}, {"title": "T1", "bpm": 100, "popularity": 50}]}, {"type": "edge_case", "inputs": [[]], "output": []}, {"type": "edge_case", "inputs": [[{"title": "Solo", "bpm": 128, "popularity": 70}]], "output": [{"title": "Solo", "bpm": 128, "popularity": 70}]}, {"type": "edge_case", "inputs": [[{"title": "LowPop", "bpm": 90, "popularity": -5}, {"title": "HighPop", "bpm": 90, "popularity": 0}, {"title": "Fast", "bpm": 150, "popularity": 100}]], "output": [{"title": "HighPop", "bpm": 90, "popularity": 0}, {"title": "LowPop", "bpm": 90, "popularity": -5}, {"title": "Fast", "bpm": 150, "popularity": 100}]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need to reorder music track info list by tempo then fame"}, {"shard_id": 2, "shard": "Each item is a dictionary holding bpm number and popularity score"}, {"shard_id": 3, "shard": "Primary sort is lower bpm should appear earlier in result"}, {"shard_id": 4, "shard": "When bpm equal pick track with bigger popularity before others"}]}}, {"problem_id": 62, "category": "string_manipulation", "name": "clean_lyrics", "domain": "music", "description": "Remove content inside brackets [], parentheses (), and consecutive duplicate lines from lyrics string, return cleaned version.", "verified": true, "reference_solution": "import re\n\ndef clean_lyrics(lyrics: str) -> str:\n    \"\"\"Remove bracketed/parenthesised content and consecutive duplicate lines.\"\"\"\n    # 1. Remove anything inside [] or () together with the brackets themselves.\n    cleaned = re.sub(r\"\\[.*?\\]|\\(.*?\\)\", \"\", lyrics, flags=re.DOTALL)\n\n    # 2. Split into lines and remove consecutive duplicates (after stripping).\n    result_lines = []\n    prev_line = None  # stores the previous **stripped** line ('' for blank)\n\n    for raw_line in cleaned.splitlines():\n        stripped_line = raw_line.strip()\n\n        if stripped_line == \"\":  # blank line handling\n            if prev_line == \"\":\n                # skip if previous was also blank -> collapse multiple blanks\n                continue\n            result_lines.append(\"\")\n            prev_line = \"\"\n        else:\n            if stripped_line != prev_line:\n                result_lines.append(stripped_line)\n                prev_line = stripped_line\n            # if it is the same as previous, skip (remove consecutive duplicate)\n\n    return \"\\n\".join(result_lines)\n", "reference_tests": [{"type": "basic", "inputs": ["[Intro] La la la\nLa la la\nLa la la"], "output": "La la la"}, {"type": "basic", "inputs": ["Hello (whisper)\nHello\nWorld"], "output": "Hello\nWorld"}, {"type": "edge_case", "inputs": ["Boom\n\nBoom\nBoom"], "output": "Boom\n\nBoom"}, {"type": "edge_case", "inputs": ["Love [Chorus: x2]\nLove\n(Love)\nLove"], "output": "Love\n\nLove"}, {"type": "edge_case", "inputs": [""], "output": ""}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Given song text output cleaned version without clutter"}, {"shard_id": 2, "shard": "Scrub any segment between square or round symbols"}, {"shard_id": 3, "shard": "Remove runs of duplicate lines keep first occurrence"}, {"shard_id": 4, "shard": "Retain single blank line gaps input one string return cleaned string"}]}}, {"problem_id": 63, "category": "math", "name": "transpose_chords", "domain": "music", "description": "Given list of chord names and semitone shift, transpose each chord, preserving major/minor suffix, wrapping within chromatic scale.", "verified": true, "reference_solution": "def transpose_chords(chords, shift):\n    \"\"\"Transpose a list of chord names by a given number of semitones.\n\n    Parameters\n    ----------\n    chords : list[str]\n        List with chord strings (e.g. \"C\", \"Am\", \"F#\", \"Bb\", etc.). A minor chord\n        is identified by the suffix \"m\"; everything else is preserved as-is.\n    shift : int\n        Number of semitones to shift. Positive values transpose up, negative\n        values transpose down.\n\n    Returns\n    -------\n    list[str]\n        List with transposed chords (roots given in sharp notation).\n    \"\"\"\n    # Mapping of note names (including enharmonic spellings) to chromatic index\n    root_to_idx = {\n        'C': 0,  'B#': 0,\n        'C#': 1, 'Db': 1,\n        'D': 2,\n        'D#': 3, 'Eb': 3,\n        'E': 4,  'Fb': 4,\n        'F': 5,  'E#': 5,\n        'F#': 6, 'Gb': 6,\n        'G': 7,\n        'G#': 8, 'Ab': 8,\n        'A': 9,\n        'A#': 10, 'Bb': 10,\n        'B': 11, 'Cb': 11,\n    }\n\n    # Canonical sharp names for each chromatic index\n    idx_to_root = [\n        'C', 'C#', 'D', 'D#', 'E', 'F',\n        'F#', 'G', 'G#', 'A', 'A#', 'B'\n    ]\n\n    def _split_chord(chord):\n        \"\"\"Split chord into root and suffix (e.g. 'C#m' -> ('C#', 'm')).\"\"\"\n        if not chord:\n            raise ValueError(\"Empty chord name is not allowed\")\n        root = chord[0]\n        idx = 1\n        if len(chord) > 1 and chord[1] in ('#', 'b'):\n            root += chord[1]\n            idx = 2\n        suffix = chord[idx:]\n        return root, suffix\n\n    transposed = []\n    for chord in chords:\n        root, suffix = _split_chord(chord)\n        if root not in root_to_idx:\n            raise ValueError(f\"Unknown chord root: {root}\")\n        new_idx = (root_to_idx[root] + shift) % 12\n        new_root = idx_to_root[new_idx]\n        transposed.append(new_root + suffix)\n    return transposed", "reference_tests": [{"type": "basic", "inputs": [["C", "G", "Am"], 2], "output": ["D", "A", "Bm"]}, {"type": "basic", "inputs": [["F#", "C#m", "G#"], -1], "output": ["F", "Cm", "G"]}, {"type": "basic", "inputs": [["Bb", "Eb", "F"], 3], "output": ["C#", "F#", "G#"]}, {"type": "edge_case", "inputs": [["C", "Dm", "E"], 0], "output": ["C", "Dm", "E"]}, {"type": "edge_case", "inputs": [["D", "Em", "Gb"], 14], "output": ["E", "F#m", "G#"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Shift every chord root by some semitone amount while keeping its major or minor tag"}, {"shard_id": 2, "shard": "Input has a chord list plus an integer telling how many steps to move"}, {"shard_id": 3, "shard": "Use twelve tone circle C then C sharp through B and wrap when counting past end"}, {"shard_id": 4, "shard": "Return same sized list with new sharp style roots and original suffixes unchanged"}]}}, {"problem_id": 64, "category": "geometry", "name": "speaker_array_layout", "domain": "music", "description": "Compute coordinates of n speakers equally spaced on circle radius r centered at origin, starting angle 0 on positive x-axis.", "sample_type": "code_synthetic"}, {"problem_id": 65, "category": "list_processing", "name": "segment_playlist", "domain": "music", "description": "Split playlist durations into contiguous segments whose total not exceed limit L. Return list of segment lengths.", "verified": true, "reference_solution": "def segment_playlist(durations, L):\n    \"\"\"Split the given playlist into contiguous segments whose total duration\n    does not exceed L. Return a list where each element is the number of tracks\n    in the corresponding segment (i.e., the segment length in items).\"\"\"\n    segments = []\n    current_sum = 0\n    current_count = 0\n\n    for d in durations:\n        # If adding this track would exceed the limit, close current segment\n        if current_count and current_sum + d > L:\n            segments.append(current_count)\n            current_sum = 0\n            current_count = 0\n        # Start / continue current segment\n        current_sum += d\n        current_count += 1\n    # Append the last segment if present\n    if current_count:\n        segments.append(current_count)\n\n    return segments", "reference_tests": [{"type": "basic", "inputs": [[4, 2, 3, 5], 6], "output": [2, 1, 1]}, {"type": "basic", "inputs": [[1, 2, 3], 3], "output": [2, 1]}, {"type": "edge_case", "inputs": [[], 10], "output": []}, {"type": "edge_case", "inputs": [[5, 5, 5], 20], "output": [3]}, {"type": "edge_case", "inputs": [[7], 10], "output": [1]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Goal split playlist into consecutive groups where each group time stays within limit"}, {"shard_id": 2, "shard": "Input a list of durations and a maximum allowed sum number"}, {"shard_id": 3, "shard": "Process sequentially starting new group whenever adding next duration breaks the limit"}, {"shard_id": 4, "shard": "Output list showing counts of tracks in each group in their original order"}]}}, {"problem_id": 66, "category": "combinatorics", "name": "weather_outfit_options", "domain": "weather", "description": "Given lists of tops, bottoms, and accessories, count outfit combinations where accessories optional but at most two chosen.", "verified": true, "reference_solution": "def weather_outfit_options(tops, bottoms, accessories):\n    \"\"\"Return number of possible outfit combinations.\n    Each outfit must have exactly one top and one bottom.\n    Accessories are optional; you may pick 0, 1 or 2 distinct accessories.\n    \"\"\"\n    # If no tops or bottoms, no outfit can be formed\n    if not tops or not bottoms:\n        return 0\n\n    a = len(accessories)\n    # combinations for picking 0,1,2 accessories without repetition\n    accessory_choices = 1 + a  # choose 0 or 1\n    if a >= 2:\n        accessory_choices += a * (a - 1) // 2  # choose 2 distinct accessories\n    total = len(tops) * len(bottoms) * accessory_choices\n    return total", "reference_tests": [{"type": "basic", "inputs": [["t1", "t2"], ["b1"], ["a1", "a2"]], "output": 8}, {"type": "basic", "inputs": [["top"], ["bottom1", "bottom2", "bottom3"], []], "output": 3}, {"type": "edge_case", "inputs": [["shirt"], ["jeans"], ["watch"]], "output": 2}, {"type": "edge_case", "inputs": [[], ["b1"], ["a1", "a2", "a3"]], "output": 0}, {"type": "edge_case", "inputs": [["t1"], ["b1"], ["a1", "a2", "a3", "a4"]], "output": 11}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Figure how many outfits you could build from clothing lists"}, {"shard_id": 2, "shard": "Each outfit must use one top item and one bottom"}, {"shard_id": 3, "shard": "Accessories add zero one or two unique pieces max"}, {"shard_id": 4, "shard": "Receive lists return single count of distinct outfit possibilities"}]}}, {"problem_id": 67, "category": "date_time", "name": "sunrise_sequence_breaks", "domain": "weather", "description": "Given list of daily sunrise times HH:MM, count how many times sequence decreases relative to previous day (earlier sunrise).", "verified": true, "reference_solution": "def sunrise_sequence_breaks(times):\n    \"\"\"Count the number of times the sunrise time becomes earlier than the previous day.\n\n    Parameters\n    ----------\n    times : list[str]\n        List of sunrise times in 'HH:MM' 24-hour format.\n\n    Returns\n    -------\n    int\n        Number of decreases in the sequence.\n    \"\"\"\n    count = 0\n    prev_minutes = None\n\n    for t in times:\n        # Convert 'HH:MM' to minutes since midnight\n        hours, minutes = map(int, t.split(':'))\n        total_minutes = hours * 60 + minutes\n\n        if prev_minutes is not None and total_minutes < prev_minutes:\n            count += 1\n        prev_minutes = total_minutes\n\n    return count", "reference_tests": [{"type": "basic", "inputs": [["06:30", "06:29", "06:28"]], "output": 2}, {"type": "basic", "inputs": [["07:00", "07:05", "07:10"]], "output": 0}, {"type": "edge_case", "inputs": [[]], "output": 0}, {"type": "edge_case", "inputs": [["05:50"]], "output": 0}, {"type": "edge_case", "inputs": [["06:00", "05:59", "06:01", "05:58"]], "output": 2}, {"type": "edge_case", "inputs": [["23:59", "00:00"]], "output": 1}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Find drops in a sequence of sunrise times"}, {"shard_id": 2, "shard": "Input is a list of times written as HH MM twenty four hour"}, {"shard_id": 3, "shard": "Add one to a counter when a day shows an earlier time than the day before"}, {"shard_id": 4, "shard": "Example 06 30 then 06 29 then 06 28 should return two"}]}}, {"problem_id": 68, "category": "parsing", "name": "decode_weather_station", "domain": "weather", "description": "Parse string 'ID|lat lon|tempC' into dict with int id, float lat, lon, and temp in Fahrenheit.", "verified": true, "reference_solution": "def decode_weather_station(record: str):\n    \"\"\"Decode a weather station record of the form 'ID|lat lon|tempC' and\n    return a dictionary with keys:\n        id   -> int      (station ID)\n        lat  -> float    (latitude)\n        lon  -> float    (longitude)\n        tempF -> float   (temperature converted to Fahrenheit)\n    The function is tolerant to additional surrounding whitespace.\n    \"\"\"\n    # Split the record into three main components\n    try:\n        id_part, coord_part, temp_part = record.split('|', 2)\n    except ValueError:\n        raise ValueError(\"Record must contain exactly two '|' separators\") from None\n\n    # Parse ID\n    station_id = int(id_part.strip())\n\n    # Parse latitude and longitude\n    coord_tokens = coord_part.strip().split()\n    if len(coord_tokens) != 2:\n        raise ValueError(\"Coordinate part must contain exactly two numbers: 'lat lon'\")\n    lat, lon = map(float, coord_tokens)\n\n    # Parse temperature in Celsius and convert to Fahrenheit\n    temp_c = float(temp_part.strip())\n    temp_f = temp_c * 9 / 5 + 32\n\n    return {\n        \"id\": station_id,\n        \"lat\": lat,\n        \"lon\": lon,\n        \"tempF\": temp_f,\n    }", "reference_tests": [{"type": "basic", "inputs": ["123|52.5 13.4|20"], "output": {"id": 123, "lat": 52.5, "lon": 13.4, "tempF": 68.0}}, {"type": "basic", "inputs": ["7|-34.5 -58.4|25.6"], "output": {"id": 7, "lat": -34.5, "lon": -58.4, "tempF": 78.08}}, {"type": "edge_case", "inputs": ["42| 0 0 | -40"], "output": {"id": 42, "lat": 0.0, "lon": 0.0, "tempF": -40.0}}, {"type": "edge_case", "inputs": ["0|90 -180|100"], "output": {"id": 0, "lat": 90.0, "lon": -180.0, "tempF": 212.0}}, {"type": "edge_case", "inputs": ["999|  12.345   67.89  |  15.5  "], "output": {"id": 999, "lat": 12.345, "lon": 67.89, "tempF": 59.9}}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Goal convert weather line into dictionary"}, {"shard_id": 2, "shard": "Line looks like id verticalbar lat lon verticalbar temp in Celsius"}, {"shard_id": 3, "shard": "Strip extra spaces parse id as int lat lon float"}, {"shard_id": 4, "shard": "Return keys id lat lon tempF where tempF is Celsius times nine fifth plus thirty two"}]}}, {"problem_id": 69, "category": "searching", "name": "locate_calm_period", "domain": "weather", "description": "Find earliest contiguous subarray of length k where all wind speeds below threshold. Return starting index or -1.", "verified": true, "reference_solution": "def locate_calm_period(speeds, k, threshold):\n    \"\"\"Return the earliest starting index of a contiguous subarray of length k\n    where every wind speed is strictly less than `threshold`. If no such\n    subarray exists, return -1.\n\n    Parameters\n    ----------\n    speeds : list[int]\n        List of recorded wind speeds.\n    k : int\n        Length of the required subarray.\n    threshold : int\n        Speed threshold that all elements of the subarray must be below.\n    \"\"\"\n    n = len(speeds)\n\n    # Quick rejection cases\n    if k <= 0 or k > n:\n        return -1\n\n    # Count how many of the first window violate the condition\n    bad = sum(1 for i in range(k) if speeds[i] >= threshold)\n    if bad == 0:\n        return 0\n\n    # Slide the window across the array\n    for start in range(1, n - k + 1):\n        # remove the leftmost element of the previous window\n        if speeds[start - 1] >= threshold:\n            bad -= 1\n        # add the new rightmost element\n        if speeds[start + k - 1] >= threshold:\n            bad += 1\n        # if window is valid\n        if bad == 0:\n            return start\n\n    return -1", "reference_tests": [{"type": "basic", "inputs": [[3, 4, 2, 1, 5], 2, 3], "output": 2}, {"type": "basic", "inputs": [[1, 1, 1], 3, 2], "output": 0}, {"type": "edge_case", "inputs": [[4, 5, 6], 1, 4], "output": -1}, {"type": "edge_case", "inputs": [[1, 2], 3, 5], "output": -1}, {"type": "edge_case", "inputs": [[0, 1, 5, 1, 0], 2, 2], "output": 0}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need earliest calm stretch in wind speed list length k under limit"}, {"shard_id": 2, "shard": "Input three things speeds list integer k and threshold speed"}, {"shard_id": 3, "shard": "Output smallest index where k consecutive speeds all below threshold else minus one"}, {"shard_id": 4, "shard": "Return minus one for impossible cases like k bigger than list size"}]}}, {"problem_id": 70, "category": "hashing", "name": "weather_cache_key", "domain": "weather", "description": "Generate cache key for query parameters dict by sorting keys alphabetically and SHA1 hashing 'key=value' joined with '&'. Return 16-char prefix.", "verified": true, "reference_solution": "import hashlib\n\ndef weather_cache_key(params: dict) -> str:\n    \"\"\"Generate a 16-character cache-key prefix for a dictionary of query\n    parameters.  The key is built by:\n    1. Sorting the dictionary keys alphabetically.\n    2. Building a query-string of the form \"key=value\" joined by '&'.\n    3. Producing the SHA1 hex digest of that string.\n    4. Returning the first 16 hexadecimal characters (prefix).\n    \"\"\"\n    if not params:\n        return hashlib.sha1(b\"\").hexdigest()[:16]\n\n    # Sort keys and build the canonical query string\n    parts = []\n    for k in sorted(params):\n        v = params[k]\n        # Convert non-string values to string before concatenation\n        parts.append(f\"{k}={v}\")\n    canonical = \"&\".join(parts)\n\n    return hashlib.sha1(canonical.encode()).hexdigest()[:16]\n", "reference_tests": [{"type": "basic", "inputs": [{}], "output": "da39a3ee5e6b4b0d"}, {"type": "edge_case", "inputs": [{}], "output": "da39a3ee5e6b4b0d"}, {"type": "basic", "inputs": [{}], "output": "da39a3ee5e6b4b0d"}, {"type": "edge_case", "inputs": [{}], "output": "da39a3ee5e6b4b0d"}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Make sixteen character cache key from query data"}, {"shard_id": 2, "shard": "Take dict maybe empty produce hex result always same for no data"}, {"shard_id": 3, "shard": "Sort keys alphabetically glue each as key=value with ampersand"}, {"shard_id": 4, "shard": "Run sha1 on that line output first sixteen hex characters"}]}}, {"problem_id": 71, "category": "set_operations", "name": "iot_shared_sensors", "domain": "IoT", "description": "Return list of sensor IDs connected to at least two different hubs, preserving ascending numeric order.", "verified": true, "reference_solution": "def iot_shared_sensors(hubs):\n    \"\"\"Return a sorted list of sensor IDs that are connected to at least two different hubs.\n\n    Parameters\n    ----------\n    hubs : Iterable[Iterable[int]]\n        An iterable where each element represents the collection (list, set, etc.) of sensor\n        IDs connected to a single hub. Sensor IDs are integers.\n\n    Returns\n    -------\n    List[int]\n        Sorted (ascending) list of sensor IDs present in at least two different hubs.\n    \"\"\"\n    from collections import Counter\n\n    # Count how many hubs each sensor appears in (ignore duplicates inside a single hub)\n    sensor_hub_count = Counter()\n    for hub_sensors in hubs:\n        # Convert to set() so duplicates within the same hub are only counted once per hub\n        for sensor_id in set(hub_sensors):\n            sensor_hub_count[sensor_id] += 1\n\n    # Select sensors that occur in 2 or more hubs and return them sorted\n    return sorted([sensor for sensor, cnt in sensor_hub_count.items() if cnt >= 2])", "reference_tests": [{"type": "basic", "inputs": [[[1, 2, 3], [3, 4], [5]]], "output": [3]}, {"type": "basic", "inputs": [[[1, 2], [2, 3], [2, 4], [5]]], "output": [2]}, {"type": "edge_case", "inputs": [[[1, 1, 1], [1], [2, 2], [2]]], "output": [1, 2]}, {"type": "edge_case", "inputs": [[[1], [2], [3]]], "output": []}, {"type": "edge_case", "inputs": [[[1, 2], [1, 2], [1, 2]]], "output": [1, 2]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Goal give IDs of sensors shared by multiple hubs"}, {"shard_id": 2, "shard": "Input many lists one per hub each list holds integer sensor IDs"}, {"shard_id": 3, "shard": "Result must be unique IDs sorted ascending order"}, {"shard_id": 4, "shard": "Include an ID only if it appears in two or more hubs"}]}}, {"problem_id": 72, "category": "bitwise", "name": "encode_device_status", "domain": "IoT", "description": "Pack boolean statuses (online, battery_low, fault) into 3-bit integer with bit0 online, bit1 battery_low, bit2 fault.", "sample_type": "code_synthetic"}, {"problem_id": 73, "category": "simulation", "name": "simulate_temperature_control", "domain": "IoT", "description": "Given target temp and list of room readings, simulate thermostat toggling: heater on when reading <target-0.5, off when >target+0.5. Return list of states 'ON'/'OFF'.", "verified": true, "reference_solution": "def simulate_temperature_control(target_temperature, readings):\n    \"\"\"Simulate a thermostat with simple hysteresis control.\n\n    The heater is switched ON when the temperature reading drops strictly below\n    (target - 0.5) and switched OFF when the reading rises strictly above\n    (target + 0.5). When the reading lies within the buffer zone\n    [target - 0.5, target + 0.5], the current state is maintained.\n\n    Parameters\n    ----------\n    target_temperature : float\n        Desired target temperature.\n    readings : list[float]\n        Chronological list of temperature readings.\n\n    Returns\n    -------\n    list[str]\n        List containing the heater state (\"ON\" or \"OFF\") after each reading.\n    \"\"\"\n\n    lower_threshold = target_temperature - 0.5\n    upper_threshold = target_temperature + 0.5\n\n    state = \"OFF\"  # Initial state\n    result = []\n\n    for temp in readings:\n        if temp < lower_threshold:\n            state = \"ON\"\n        elif temp > upper_threshold:\n            state = \"OFF\"\n        # else: retain previous state\n        result.append(state)\n\n    return result", "reference_tests": [{"type": "basic", "inputs": [20, [19, 19.5, 20, 21]], "output": ["ON", "ON", "ON", "OFF"]}, {"type": "basic", "inputs": [22, [23, 22.6, 22, 21.4]], "output": ["OFF", "OFF", "OFF", "ON"]}, {"type": "edge_case", "inputs": [18.5, []], "output": []}, {"type": "edge_case", "inputs": [25, [24, 24.4, 24.49, 24.51, 24.9, 25.6, 25.4, 25]], "output": ["ON", "ON", "ON", "ON", "ON", "OFF", "OFF", "OFF"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Make a simple thermostat history from temperature readings"}, {"shard_id": 2, "shard": "You get a target number and a list of room temperatures"}, {"shard_id": 3, "shard": "Switch heater to ON whenever reading drops below target minus zero point five"}, {"shard_id": 4, "shard": "Switch to OFF when it rises above target plus zero point five else keep state"}]}}, {"problem_id": 74, "category": "recursion", "name": "device_tree_paths", "domain": "IoT", "description": "Given dict child mapping, return all root-to-leaf id paths as lists using recursion.", "verified": false, "sample_type": "code_synthetic"}, {"problem_id": 75, "category": "counting", "name": "count_firmware_versions", "domain": "IoT", "description": "Count occurrences of each firmware version in device list; return dict excluding versions installed on only one device.", "verified": true, "reference_solution": "def count_firmware_versions(devices):\n    \"\"\"Count occurrences of each firmware version in devices list, excluding those installed on only one device.\n\n    Args:\n        devices (list): List of firmware version identifiers (hashable items).\n\n    Returns:\n        dict: Mapping of firmware version to its count (only versions with count > 1).\n    \"\"\"\n    from collections import Counter\n\n    # Fast exit for empty input\n    if not devices:\n        return {}\n\n    counts = Counter(devices)\n    # Filter out versions that appear only once\n    result = {version: cnt for version, cnt in counts.items() if cnt > 1}\n    return result", "reference_tests": [{"type": "basic", "inputs": [["1.0", "1.0", "2.0", "3.1", "3.1", "3.1"]], "output": {"1.0": 2, "3.1": 3}}, {"type": "basic", "inputs": [["A", "B", "A", "C", "B", "A"]], "output": {"A": 3, "B": 2}}, {"type": "edge_case", "inputs": [[]], "output": {}}, {"type": "edge_case", "inputs": [["v1"]], "output": {}}, {"type": "edge_case", "inputs": [["x", "y", "z", "z"]], "output": {"z": 2}}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Count firmware versions that appear on more than one device"}, {"shard_id": 2, "shard": "Input is a plain list of version labels like 1 dot 0"}, {"shard_id": 3, "shard": "Return a mapping version to count omit singles"}, {"shard_id": 4, "shard": "Example list with 1 dot 0 twice keeps 1 dot 0 count two"}]}}, {"problem_id": 76, "category": "greedy", "name": "min_patches_for_security", "domain": "cybersecurity", "description": "Given sorted list of vulnerability severities and patch capacity m, greedily patch highest severity until capacity exhausted; return list of patched severities.", "verified": true, "reference_solution": "def min_patches_for_security(m, severities):\n    \"\"\"Return a list with up to m highest vulnerability severities to patch.\n\n    Parameters\n    ----------\n    m : int\n        Maximum number of vulnerabilities that can be patched.\n    severities : list[int]\n        Sorted list (ascending) of vulnerability severities.\n\n    Returns\n    -------\n    list[int]\n        List of patched severities in descending order (highest first).\n    \"\"\"\n    # Guard against empty list or non-positive capacity\n    if m <= 0 or not severities:\n        return []\n\n    # How many items we can patch\n    k = min(m, len(severities))\n\n    # Since severities are sorted ascending, take the last k elements\n    highest = severities[-k:]\n\n    # Return in descending order so the most severe appears first\n    return sorted(highest, reverse=True)", "reference_tests": [{"type": "basic", "inputs": [2, [1, 2, 5, 7]], "output": [7, 5]}, {"type": "basic", "inputs": [3, [10, 20, 30]], "output": [30, 20, 10]}, {"type": "edge_case", "inputs": [5, [4, 8]], "output": [8, 4]}, {"type": "edge_case", "inputs": [0, [1, 2, 3]], "output": []}, {"type": "edge_case", "inputs": [-1, [1, 5]], "output": []}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Pick which bugs to fix prioritizing worst ones"}, {"shard_id": 2, "shard": "You get a number m and an ascending severity list"}, {"shard_id": 3, "shard": "Take at most m top severities starting from the end"}, {"shard_id": 4, "shard": "Return them ordered high to low as final patched list"}]}}, {"problem_id": 77, "category": "formatting", "name": "format_hex_dump", "domain": "cybersecurity", "description": "Format bytes object into hex dump with 16 bytes per line, addresses starting at 0000, uppercase hex, and ASCII preview.", "sample_type": "code_synthetic"}, {"problem_id": 78, "category": "validation", "name": "validate_password_rules", "domain": "cybersecurity", "description": "Check password at least 12 chars, contains upper, lower, digit, special, and no substring from blacklist list.", "verified": true, "reference_solution": "import re\n\ndef validate_password_rules(password: str, blacklist: list) -> bool:\n    \"\"\"Return True if password satisfies all rules, else False.\n    Rules:\n    1. At least 12 characters long.\n    2. Contains at least one uppercase letter.\n    3. Contains at least one lowercase letter.\n    4. Contains at least one digit.\n    5. Contains at least one special character (non-alphanumeric).\n    6. Does not contain (case-insensitive) any substring from the blacklist.\n    \"\"\"\n    # Rule 1: length\n    if len(password) < 12:\n        return False\n\n    # Rule 2-5: character variety\n    has_upper = bool(re.search(r'[A-Z]', password))\n    has_lower = bool(re.search(r'[a-z]', password))\n    has_digit = bool(re.search(r'\\d', password))\n    has_special = bool(re.search(r'[^A-Za-z0-9]', password))\n\n    if not (has_upper and has_lower and has_digit and has_special):\n        return False\n\n    # Rule 6: blacklist substrings (case-insensitive)\n    lower_pass = password.lower()\n    for bad in blacklist:\n        if bad and bad.lower() in lower_pass:\n            return False\n\n    return True\n", "reference_tests": [{"type": "basic", "inputs": ["StrongPass123!", ["password", "123456"]], "output": true}, {"type": "basic", "inputs": ["Short1!", []], "output": false}, {"type": "basic", "inputs": ["StrongPass123", []], "output": false}, {"type": "edge_case", "inputs": ["MyPasswordIsStrong123!", ["password"]], "output": false}, {"type": "edge_case", "inputs": ["NoDigitPass!", []], "output": false}, {"type": "edge_case", "inputs": ["ValidOne#2023", []], "output": true}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Validate strong passwords against a forbidden words list return true or false"}, {"shard_id": 2, "shard": "Password needs at least twelve characters and must contain uppercase and lowercase letters"}, {"shard_id": 3, "shard": "Also require at least one digit plus one special non alphanumeric symbol"}, {"shard_id": 4, "shard": "Fail if any blacklist word appears ignoring case otherwise pass the password"}]}}, {"problem_id": 79, "category": "statistics", "name": "failed_login_rate", "domain": "cybersecurity", "description": "Given timestamps of attempts and bool success, compute percentage failures in last hour relative to provided reference time.", "sample_type": "code_synthetic"}, {"problem_id": 80, "category": "filtering", "name": "filter_ip_range", "domain": "cybersecurity", "description": "Return IPs not within any CIDR ranges in blacklist list. IPv4 only, no subnet > /8.", "verified": true, "reference_solution": "def filter_ip_range(ips, blacklist):\n    \"\"\"Return list of IP strings from `ips` that are NOT contained in any CIDR\n    network present in `blacklist`.\n\n    Args:\n        ips (list[str]): List of IPv4 address strings.\n        blacklist (list[str]): List of IPv4 CIDR blocks (e.g., \"192.168.0.0/16\").\n\n    Returns:\n        list[str]: Filtered list with the same order as `ips`, excluding those\n                    addresses that fall inside any blacklisted network.\n    \"\"\"\n    import ipaddress\n\n    # Convert blacklist entries to IPv4Network objects once for efficiency\n    networks = []\n    for cidr in blacklist:\n        try:\n            networks.append(ipaddress.IPv4Network(cidr, strict=False))\n        except ValueError:\n            # Skip malformed CIDR blocks (problem statement doesn't specify, but safer)\n            continue\n\n    # Prepare result while preserving order\n    result = []\n    for ip_str in ips:\n        try:\n            ip_obj = ipaddress.IPv4Address(ip_str)\n        except ValueError:\n            # Ignore malformed IP addresses (problem statement doesn't specify)\n            continue\n        # Check membership in any blacklist network\n        if not any(ip_obj in net for net in networks):\n            result.append(ip_str)\n    return result", "reference_tests": [{"type": "basic", "inputs": [["192.168.1.1", "10.0.0.5", "172.16.0.1"], ["192.168.0.0/16"]], "output": ["10.0.0.5", "172.16.0.1"]}, {"type": "basic", "inputs": [["8.8.8.8", "1.1.1.1"], []], "output": ["8.8.8.8", "1.1.1.1"]}, {"type": "edge_case", "inputs": [[], ["10.0.0.0/8"]], "output": []}, {"type": "edge_case", "inputs": [["10.0.1.1", "192.0.2.1"], ["10.0.0.0/8", "10.0.0.0/16"]], "output": ["192.0.2.1"]}, {"type": "edge_case", "inputs": [["203.0.113.5", "203.0.113.6"], ["203.0.113.5/32"]], "output": ["203.0.113.6"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Remove addresses inside any blacklisted CIDR range"}, {"shard_id": 2, "shard": "Input two lists ipv4 strings and cidr blocks maximal mask eight"}, {"shard_id": 3, "shard": "Return addresses not contained keep original order duplicates preserved"}, {"shard_id": 4, "shard": "Block 192.168.0.0/16 lets 10.0.0.5 through"}]}}, {"problem_id": 81, "category": "sorting", "name": "sort_bus_routes", "domain": "transport", "description": "Sort bus route tuples (line, start, end, distance) primarily by ascending distance, secondarily by line numeric part.", "sample_type": "code_synthetic"}, {"problem_id": 82, "category": "string_manipulation", "name": "normalize_license_plate", "domain": "transport", "description": "Remove spaces and dashes, convert letters to uppercase, return standardized plate string.", "verified": true, "reference_solution": "def normalize_license_plate(plate: str) -> str:\n    \"\"\"Return the license plate string without spaces or dashes and with\n    all alphabetical characters in uppercase.\n    Example: \"ab- c 123\" -> \"ABC123\"\"\"    \n    # Remove spaces and dashes then convert the remaining string to uppercase\n    return ''.join(ch for ch in plate if ch not in ' -').upper()", "reference_tests": [{"type": "basic", "inputs": ["abc 123"], "output": "ABC123"}, {"type": "basic", "inputs": ["ab-c- 123"], "output": "ABC123"}, {"type": "edge_case", "inputs": ["ABC123"], "output": "ABC123"}, {"type": "edge_case", "inputs": ["  abc-123  "], "output": "ABC123"}, {"type": "edge_case", "inputs": ["ab@12-c"], "output": "AB@12C"}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need to tidy a license string and make it uniform"}, {"shard_id": 2, "shard": "Throw out spaces and dash characters when you see them"}, {"shard_id": 3, "shard": "Any letters left should change to big caps format"}, {"shard_id": 4, "shard": "Return the joined result as final plate text input string out string"}]}}, {"problem_id": 83, "category": "math", "name": "fuel_consumption_estimate", "domain": "transport", "description": "Compute total liters needed for trip segments given km and efficiency km/l. Apply 5% safety margin then round up to one decimal.", "verified": true, "reference_solution": "import math\n\ndef fuel_consumption_estimate(segments, efficiency):\n    \"\"\"Estimate the amount of fuel (in liters) required for a trip.\n\n    Parameters\n    ----------\n    segments : iterable of numbers\n        Distances (in kilometers) for each segment of the trip.\n    efficiency : float\n        Vehicle fuel efficiency in km per liter.\n\n    Returns\n    -------\n    float\n        Total liters required, including a 5% safety margin, rounded up to the\n        nearest tenth (one decimal place).\n    \"\"\"\n    # Validate inputs (basic checks; raise ValueError for impossible cases)\n    if efficiency <= 0:\n        raise ValueError(\"Efficiency must be positive and non-zero.\")\n\n    # Calculate total distance\n    total_km = sum(segments)\n\n    # Base fuel needed (in liters)\n    if total_km == 0:\n        return 0.0\n    liters_needed = total_km / efficiency\n\n    # Apply 5% safety margin\n    liters_with_margin = liters_needed * 1.05\n\n    # Round up to the nearest 0.1 liter\n    rounded_up = math.ceil(liters_with_margin * 10) / 10.0\n    return rounded_up\n", "reference_tests": [{"type": "basic", "inputs": [[100], 10], "output": 10.5}, {"type": "basic", "inputs": [[50, 75], 12], "output": 11.0}, {"type": "edge_case", "inputs": [[], 15], "output": 0.0}, {"type": "edge_case", "inputs": [[33.3], 13.3], "output": 2.7}, {"type": "edge_case", "inputs": [[0, 0], 5], "output": 0.0}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Find how many liters are needed for the whole trip"}, {"shard_id": 2, "shard": "Input is many kilometer segments plus one efficiency in km per liter"}, {"shard_id": 3, "shard": "After summing distance add a five percent margin"}, {"shard_id": 4, "shard": "Then round upward to one decimal for the answer"}]}}, {"problem_id": 84, "category": "geometry", "name": "intersection_area_two_circles", "domain": "transport", "description": "Given centers and radii of two circles, compute intersection area rounded 4 decimals. Assume inputs guarantee some overlap.", "verified": true, "reference_solution": "import math\n\ndef intersection_area_two_circles(x1, y1, r1, x2, y2, r2):\n    \"\"\"Return the area of intersection of two circles rounded to 4 decimals.\n    Parameters are centre coordinates and radii: (x1, y1, r1, x2, y2, r2)\n    \"\"\"\n    # Distance between centres\n    dx = x2 - x1\n    dy = y2 - y1\n    d = math.hypot(dx, dy)\n\n    # No overlap\n    if d >= r1 + r2:\n        return 0.0\n\n    # One circle completely inside the other (includes coincident centres)\n    if d <= abs(r1 - r2):\n        return round(math.pi * min(r1, r2) ** 2, 4)\n\n    # Partial overlap\n    # Formula components\n    alpha = math.acos((d**2 + r1**2 - r2**2) / (2 * d * r1))\n    beta = math.acos((d**2 + r2**2 - r1**2) / (2 * d * r2))\n\n    area1 = r1**2 * alpha\n    area2 = r2**2 * beta\n\n    # Segment of intersection (lens) area\n    area3 = 0.5 * math.sqrt(\n        max(0.0, (-d + r1 + r2) * (d + r1 - r2) * (d - r1 + r2) * (d + r1 + r2))\n    )\n\n    intersection = area1 + area2 - area3\n    return round(intersection, 4)\n", "reference_tests": [{"type": "basic", "inputs": [0, 0, 2, 3, 0, 2], "output": 1.8132}, {"type": "basic", "inputs": [0, 0, 3, 5, 0, 4], "output": 6.6417}, {"type": "edge_case", "inputs": [0, 0, 1, 1.5, 0, 1], "output": 0.4533}, {"type": "edge_case", "inputs": [0, 0, 5, 1, 1, 2], "output": 12.5664}, {"type": "edge_case", "inputs": [0, 0, 1, 0, 0, 1], "output": 3.1416}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Compute how much two circles intersect area wise"}, {"shard_id": 2, "shard": "Input six numbers center x y and radius for each circle"}, {"shard_id": 3, "shard": "Output single float being the intersection surface rounded to four decimals"}, {"shard_id": 4, "shard": "You can trust circles definitely overlap at least partly"}]}}, {"problem_id": 85, "category": "list_processing", "name": "merge_route_stops", "domain": "transport", "description": "Merge two sorted stop name lists into one sorted list without duplicates, preserving original case from first appearance.", "verified": true, "reference_solution": "def merge_route_stops(route_a, route_b):\n    \"\"\"Merge two alphabetically sorted lists of stop names, returning a single\n    sorted list that contains each stop only once (duplicates are detected\n    case-insensitively).  The original capitalisation of the first occurrence\n    of every stop is preserved.\n    \"\"\"\n\n    i = j = 0\n    result = []\n    seen_lower = set()  # store lower-cased versions we've already added\n\n    # Helper that tries to append a stop if it hasn't been added yet\n    def try_add(stop):\n        key = stop.lower()\n        if key not in seen_lower:\n            seen_lower.add(key)\n            result.append(stop)\n\n    # Merge while both lists still have elements\n    while i < len(route_a) and j < len(route_b):\n        a, b = route_a[i], route_b[j]\n        a_lower, b_lower = a.lower(), b.lower()\n\n        if a_lower == b_lower:\n            # Same stop (ignoring case) appears in both lists\n            try_add(a)  # keep capitalisation from first appearance (route_a)\n            i += 1\n            j += 1\n        elif a_lower < b_lower:\n            try_add(a)\n            i += 1\n        else:  # b_lower < a_lower\n            try_add(b)\n            j += 1\n\n    # Append any leftovers from either list\n    while i < len(route_a):\n        try_add(route_a[i])\n        i += 1\n    while j < len(route_b):\n        try_add(route_b[j])\n        j += 1\n\n    return result\n", "reference_tests": [{"type": "basic", "inputs": [["Alpha", "Bravo", "Charlie"], ["Bravo", "Delta"]], "output": ["Alpha", "Bravo", "Charlie", "Delta"]}, {"type": "basic", "inputs": [["Central", "Main"], ["central", "Park", "main"]], "output": ["Central", "Main", "Park"]}, {"type": "edge_case", "inputs": [[], ["A", "B"]], "output": ["A", "B"]}, {"type": "edge_case", "inputs": [[], []], "output": []}, {"type": "edge_case", "inputs": [["Avenue", "Street"], ["Boulevard", "street", "Terrace"]], "output": ["Avenue", "Boulevard", "Street", "Terrace"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Merge two alphabetic stop name lists into one tidy list without repeats"}, {"shard_id": 2, "shard": "Keep capitalization from the first appearance when adding a stop to output"}, {"shard_id": 3, "shard": "Treat duplicates case insensitively so Bravo and bravo considered same stop"}, {"shard_id": 4, "shard": "Input two sorted string lists output one sorted list of unique stop names"}]}}, {"problem_id": 86, "category": "combinatorics", "name": "crop_rotation_patterns", "domain": "agriculture", "description": "Return number of distinct length-n crop rotations using k crops where no crop repeats consecutively.", "verified": true, "reference_solution": "def crop_rotation_patterns(n, k):\n    \"\"\"Return the number of distinct length-n crop rotations using k crops\n    where no crop repeats consecutively.\n    \n    Parameters\n    ----------\n    n : int\n        Length of the rotation (number of seasons/years).\n    k : int\n        Number of distinct crops available.\n\n    Returns\n    -------\n    int\n        Count of valid sequences where no two consecutive positions\n        (including only adjacent positions in the linear sense) contain\n        the same crop.\n    \"\"\"\n    # Handle degenerate cases first\n    if n == 0:\n        # Exactly one empty sequence regardless of k\n        return 1\n    if k == 0:\n        # No crops to place (except when n == 0, handled above)\n        return 0\n    if k == 1:\n        # Only possible if n is 1; otherwise consecutive repeat unavoidable\n        return 1 if n == 1 else 0\n\n    # First position: k ways; each subsequent: (k-1) ways.\n    return k * (k - 1) ** (n - 1)\n", "reference_tests": [{"type": "basic", "inputs": [1, 3], "output": 3}, {"type": "basic", "inputs": [2, 2], "output": 2}, {"type": "basic", "inputs": [4, 3], "output": 24}, {"type": "edge_case", "inputs": [0, 5], "output": 1}, {"type": "edge_case", "inputs": [3, 1], "output": 0}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Count crop rotations with no immediate repeat of the same crop"}, {"shard_id": 2, "shard": "Input two integers n for length and k for available crops"}, {"shard_id": 3, "shard": "Output integer number of valid rotations include special case when n is zero"}, {"shard_id": 4, "shard": "Sequences consider only adjacent positions repeats elsewhere allowed order matters"}]}}, {"problem_id": 87, "category": "date_time", "name": "next_harvest_moon", "domain": "agriculture", "description": "Given year, return YYYY-MM-DD of harvest moon (full moon nearest autumnal equinox). Use provided lookup dict for full moons.", "verified": true, "reference_solution": "def next_harvest_moon(year):\n    \"\"\"Return the YYYY-MM-DD string of the Harvest Moon for the given Gregorian\n    year.  The Harvest Moon is defined as the full moon that occurs nearest to\n    the (Northern-hemisphere) autumnal equinox.  For the purpose of this\n    function we use a pre-computed lookup table that covers several recent\n    years.  If the requested year is absent from the table, a ValueError is\n    raised.\n    \"\"\"\n\n    # Pre-computed dates of the Harvest Moon (UTC)                   \n    # Source: US Naval Observatory / timeanddate.com full-moon tables\n    harvest_moons = {\n        2018: \"2018-09-24\",  # Sep 24 (4 days after equinox)\n        2019: \"2019-09-14\",  # Sept 14 (9 days before)\n        2020: \"2020-10-01\",  # Oct 01 (9 days after)\n        2021: \"2021-09-20\",  # Sept 20 (2 days before)\n        2022: \"2022-09-10\",  # Sept 10 (12 days before)\n        2023: \"2023-09-29\",  # Sept 29 (7 days after)\n        2024: \"2024-09-17\",  # Sept 17 (5 days before)\n        2025: \"2025-10-06\",  # Oct 06 (14 days after)\n    }\n\n    if year not in harvest_moons:\n        raise ValueError(f\"Harvest-moon date for year {year} is not available\")\n\n    return harvest_moons[year]\n", "reference_tests": [{"type": "basic", "inputs": [2019], "output": "2019-09-14"}, {"type": "basic", "inputs": [2021], "output": "2021-09-20"}, {"type": "basic", "inputs": [2023], "output": "2023-09-29"}, {"type": "edge_case", "inputs": [2025], "output": "2025-10-06"}, {"type": "edge_case", "inputs": [2018], "output": "2018-09-24"}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Find date of yearly harvest moon near autumn equinox"}, {"shard_id": 2, "shard": "Input is a single gregorian year integer"}, {"shard_id": 3, "shard": "Return string formatted YYYY MM DD for that years full moon"}, {"shard_id": 4, "shard": "Throw error if year missing from provided moon date table"}]}}, {"problem_id": 88, "category": "parsing", "name": "parse_soil_report", "domain": "agriculture", "description": "Extract pH, nitrogen, phosphorus, potassium numeric values from multiline report text and return as dictionary, default None if missing.", "verified": false, "sample_type": "code_synthetic"}, {"problem_id": 89, "category": "searching", "name": "locate_weeds_cluster", "domain": "agriculture", "description": "Given grid of 0/1, find size of largest connected 1-cluster using BFS four-way connectivity.", "verified": true, "reference_solution": "def locate_weeds_cluster(grid):\n    \"\"\"Return the size of the largest 4-directionally connected cluster of 1s in the grid.\n    An empty grid or a grid without 1s yields 0.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n\n    def bfs(r, c):\n        from collections import deque\n        q = deque([(r, c)])\n        visited[r][c] = True\n        size = 0\n        while q:\n            x, y = q.popleft()\n            size += 1\n            for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == 1:\n                    visited[nx][ny] = True\n                    q.append((nx, ny))\n        return size\n\n    largest = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and not visited[i][j]:\n                largest = max(largest, bfs(i, j))\n    return largest", "reference_tests": [{"type": "basic", "inputs": [[[1, 0, 0], [1, 1, 0], [0, 0, 1]]], "output": 3}, {"type": "basic", "inputs": [[[0, 0], [0, 0]]], "output": 0}, {"type": "edge_case", "inputs": [[[1]]], "output": 1}, {"type": "edge_case", "inputs": [[]], "output": 0}, {"type": "edge_case", "inputs": [[[1, 1], [1, 1]]], "output": 4}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Goal is to report how large the biggest one patch is"}, {"shard_id": 2, "shard": "Receive a grid of zero and one numbers and output one integer"}, {"shard_id": 3, "shard": "Cells join if they touch up down left or right never diagonally"}, {"shard_id": 4, "shard": "If grid empty or lacks ones then answer should simply be zero"}]}}, {"problem_id": 90, "category": "hashing", "name": "seed_lot_identifier", "domain": "agriculture", "description": "Generate deterministic UUID v4-style string by hashing concatenation of supplier, cultivar, and batch number with SHA256.", "verified": true, "reference_solution": "import hashlib\n\ndef seed_lot_identifier(supplier, cultivar, batch_number):\n    \"\"\"Return a deterministic UUIDv4-style identifier for a seed lot.\n    The identifier is produced by:\n        1. Concatenating supplier, cultivar and batch number (as strings) with **no delimiter**.\n        2. Hashing the resulting byte string using SHA-256.\n        3. Taking the first 16 bytes (32 hex characters) of the digest.\n        4. Setting the UUID version nibble (index 12) to '4'.\n        5. Setting the variant nibble (index 16) so that the high bits are 10 (i.e. hex 8\u2013b).\n        6. Formatting as 8-4-4-4-12 hexadecimal characters separated by hyphens.\n    The function is fully deterministic: identical inputs yield identical identifiers.\n    \"\"\"\n    # Step 1: turn all inputs into strings and concatenate\n    concatenated = f\"{supplier}{cultivar}{batch_number}\"\n\n    # Step 2: SHA-256 hash and grab the first 32 hex digits (16 bytes)\n    digest = hashlib.sha256(concatenated.encode()).hexdigest()[:32]\n\n    # Work with a mutable list of characters\n    chars = list(digest)\n\n    # Step 4: force the version to 4 (index 12, 0-based)\n    chars[12] = '4'\n\n    # Step 5: set the variant (index 16)\n    original_val = int(chars[16], 16)\n    variant_val  = (original_val & 0x3) | 0x8  # set the two most-significant bits to 10\n    chars[16] = f\"{variant_val:x}\"\n\n    # Re-assemble the 32 hex characters\n    uuid_hex = \"\".join(chars)\n\n    # Step 6: insert hyphens to obtain 8-4-4-4-12 layout\n    return f\"{uuid_hex[0:8]}-{uuid_hex[8:12]}-{uuid_hex[12:16]}-{uuid_hex[16:20]}-{uuid_hex[20:]}\"", "reference_tests": [{"type": "basic", "inputs": ["", "", ""], "output": "e3b0c442-98fc-4c14-9afb-f4c8996fb924"}, {"type": "basic", "inputs": ["", "", "a"], "output": "ca978112-ca1b-4dca-bac2-31b39a23dc4d"}, {"type": "basic", "inputs": ["hello", "", ""], "output": "2cf24dba-5fb0-430e-a6e8-3b2ac5b9e29e"}, {"type": "edge_case", "inputs": ["a", "b", "c"], "output": "ba7816bf-8f01-4fea-8141-40de5dae2223"}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Create deterministic uuid v4 string from supplier cultivar and batch inputs"}, {"shard_id": 2, "shard": "Join inputs directly hash with sha256 keep first thirty two hex chars"}, {"shard_id": 3, "shard": "Set nibble twelve to four and nibble sixteen to eight through b variant"}, {"shard_id": 4, "shard": "Split into 8 4 4 4 12 hyphen blocks to finish"}]}}, {"problem_id": 91, "category": "set_operations", "name": "shared_power_sources", "domain": "energy", "description": "Return set of power source names appearing in every plant's supply list.", "verified": true, "reference_solution": "def shared_power_sources(plants):\n    \"\"\"Return a sorted list of power source names that appear in every plant's supply list.\n    If the input list is empty, or if any plant has an empty supply list, an empty list\n    is returned. The result is sorted alphabetically for deterministic comparison.\n    \"\"\"\n    # No plants at all -> no shared sources\n    if not plants:\n        return []\n\n    # Start with the set of the first plant's sources\n    shared = set(plants[0])\n\n    # Intersect with each subsequent plant's sources\n    for plant_sources in plants[1:]:\n        shared &= set(plant_sources)\n        # Early exit if intersection becomes empty\n        if not shared:\n            return []\n\n    # Return as a sorted list for deterministic ordering\n    return sorted(shared)\n", "reference_tests": [{"type": "basic", "inputs": [[["Coal", "Solar", "Wind"], ["Gas", "Solar", "Wind"], ["Solar", "Wind", "Hydro"]]], "output": ["Solar", "Wind"]}, {"type": "basic", "inputs": [[["Solar", "Hydro"]]], "output": ["Hydro", "Solar"]}, {"type": "edge_case", "inputs": [[]], "output": []}, {"type": "edge_case", "inputs": [[["Solar"], []]], "output": []}, {"type": "edge_case", "inputs": [[["Solar", "Solar", "Wind"], ["Wind", "Solar", "Wind"], ["Solar", "Wind"]]], "output": ["Solar", "Wind"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Goal find power sources common to all plants"}, {"shard_id": 2, "shard": "Input is a list of inner lists each plant supplies"}, {"shard_id": 3, "shard": "Return alphabetically sorted list of sources found in every plant"}, {"shard_id": 4, "shard": "If no plants or any list empty then output is empty"}]}}, {"problem_id": 92, "category": "bitwise", "name": "energy_meter_flag_set", "domain": "energy", "description": "Given integer state, set bit 5 to 1 and clear bit 2. Return new state.", "verified": true, "reference_solution": "def energy_meter_flag_set(state: int) -> int:\n    \"\"\"Set bit 5 (value 32) and clear bit 2 (value 4) of the given integer state.\n\n    Bits are numbered from 0 (least-significant bit). The function returns the\n    modified state leaving all other bits unchanged.\n    \"\"\"\n    # Bit masks\n    SET_BIT_5 = 1 << 5   # 32\n    CLEAR_BIT_2_MASK = ~(1 << 2)  # ...11111011 in two's-complement\n\n    # Set bit 5 then clear bit 2\n    return (state | SET_BIT_5) & CLEAR_BIT_2_MASK", "reference_tests": [{"type": "basic", "inputs": [0], "output": 32}, {"type": "basic", "inputs": [4], "output": 32}, {"type": "basic", "inputs": [36], "output": 32}, {"type": "edge_case", "inputs": [255], "output": 251}, {"type": "edge_case", "inputs": [-1], "output": -5}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Task modify a given integer by manipulating specific bits inside it"}, {"shard_id": 2, "shard": "Under zero based indexing ensure bit five holds value one"}, {"shard_id": 3, "shard": "Also flip bit two off making that position zero"}, {"shard_id": 4, "shard": "Output the new integer keeping every other bit unchanged"}]}}, {"problem_id": 93, "category": "simulation", "name": "battery_drain_sim", "domain": "energy", "description": "Simulate battery percentage decay by rate r% per hour with occasional boosts list of (hour, +value). Return list per hour until battery empty.", "sample_type": "code_synthetic"}, {"problem_id": 94, "category": "recursion", "name": "power_grid_split", "domain": "energy", "description": "Recursively split power demand integer n into list of powers of two summing to n, highest first.", "verified": true, "reference_solution": "def power_grid_split(n):\n    \"\"\"Return list of powers of two that sum to n, in descending order.\"\"\"\n    if n <= 0:\n        return []\n    result = []\n    # Traverse bits from highest to lowest\n    for k in range(n.bit_length() - 1, -1, -1):\n        p = 1 << k  # 2**k\n        if n & p:\n            result.append(p)\n    return result\n", "reference_tests": [{"type": "basic", "inputs": [13], "output": [8, 4, 1]}, {"type": "basic", "inputs": [1], "output": [1]}, {"type": "edge_case", "inputs": [0], "output": []}, {"type": "edge_case", "inputs": [32], "output": [32]}, {"type": "basic", "inputs": [19], "output": [16, 2, 1]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Split a power demand number into smaller standardized units"}, {"shard_id": 2, "shard": "Each unit must be an exact power of two"}, {"shard_id": 3, "shard": "All chosen units together must equal the original demand"}, {"shard_id": 4, "shard": "Deliver the units list starting with the largest power"}]}}, {"problem_id": 95, "category": "counting", "name": "count_peak_hours", "domain": "energy", "description": "Given hourly usage list and threshold, count hours where usage exceeds threshold and is greater than both neighbors.", "verified": true, "reference_solution": "def count_peak_hours(usage, threshold):\n    \"\"\"Count the number of \"peak\" hours.\n\n    A peak hour i satisfies:\n        * i is not the first or last index (has two neighbors)\n        * usage[i] > threshold\n        * usage[i] is greater than both immediate neighbors\n    \"\"\"\n    if not usage or len(usage) < 3:\n        return 0\n\n    count = 0\n    # iterate from 1 to len-2 (exclude first and last)\n    for i in range(1, len(usage) - 1):\n        if usage[i] > threshold and usage[i] > usage[i - 1] and usage[i] > usage[i + 1]:\n            count += 1\n    return count", "reference_tests": [{"type": "basic", "inputs": [[1, 3, 2, 4, 1], 2], "output": 2}, {"type": "basic", "inputs": [[0, 5, 0, 6, 1, 7, 0], 4], "output": 3}, {"type": "edge_case", "inputs": [[5, 4, 3, 2, 1], 2], "output": 0}, {"type": "edge_case", "inputs": [[10, 9, 10, 9, 10], 10], "output": 0}, {"type": "edge_case", "inputs": [[5, 6], 4], "output": 0}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Count peak usage hours over a set threshold"}, {"shard_id": 2, "shard": "Input one list of hourly numbers and one threshold number"}, {"shard_id": 3, "shard": "A peak hour must beat both neighboring hours"}, {"shard_id": 4, "shard": "Skip first and last positions and return total count"}]}}, {"problem_id": 96, "category": "greedy", "name": "schedule_show_times", "domain": "entertainment", "description": "Given show durations and operating window, greedily schedule maximal number sequentially without overlap, preserving original input order when durations equal.", "verified": true, "reference_solution": "def schedule_show_times(durations, operating_window):\n    \"\"\"Return a list with the durations of the shows that can be scheduled\n    within the given operating window. Shows are picked greedily by the\n    shortest duration first; when durations are equal, the show that\n    appeared earlier in the original list is chosen first.\n    \n    Parameters\n    ----------\n    durations : list[int]\n        List with the duration of each show (positive integers).\n    operating_window : int\n        Total time available to schedule the shows (non-negative integer).\n\n    Returns\n    -------\n    list[int]\n        Durations of the scheduled shows, in the order they are placed in\n        the final schedule (i.e. the order considered by the greedy\n        algorithm).\n    \"\"\"\n    # Attach original indices to preserve stable ordering among equal durations\n    indexed = list(enumerate(durations))  # [(index, duration), ...]\n\n    # Sort primarily by duration (ascending); stable sort keeps original order\n    indexed_sorted = sorted(indexed, key=lambda x: x[1])\n\n    schedule = []\n    time_used = 0\n\n    for idx, dur in indexed_sorted:\n        if time_used + dur <= operating_window:\n            schedule.append(dur)\n            time_used += dur\n        # If the current show doesn't fit, continue to next shortest; we do NOT\n        # break, because a later show could still fit (all later ones are\n        # equal or longer, so they won't fit either). Hence, we can break.\n        elif dur > operating_window - time_used:\n            # Since list is sorted ascending, nothing else will fit.\n            break\n\n    return schedule", "reference_tests": [{"type": "basic", "inputs": [[30, 20, 10], 40], "output": [10, 20]}, {"type": "basic", "inputs": [[5, 10, 3], 8], "output": [3, 5]}, {"type": "edge_case", "inputs": [[15, 15, 15], 30], "output": [15, 15]}, {"type": "edge_case", "inputs": [[20, 30], 10], "output": []}, {"type": "edge_case", "inputs": [[], 100], "output": []}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Pick shows to fit time window using greedy shortest first"}, {"shard_id": 2, "shard": "Keep adding shows until extra one would break total window"}, {"shard_id": 3, "shard": "Input is list of show lengths plus positive window number"}, {"shard_id": 4, "shard": "Output list of accepted lengths preserves original order when equal"}]}}, {"problem_id": 97, "category": "formatting", "name": "format_cast_list", "domain": "entertainment", "description": "Format list of actor names into Oxford-comma style string with '&' before last name.", "verified": true, "reference_solution": "def format_cast_list(cast):\n    \"\"\"Convert a list of actor names into an Oxford-comma style string\n    using an ampersand (&) before the last name.\n    Examples:\n        [] -> \"\"\n        ['John'] -> 'John'\n        ['John', 'Jane'] -> 'John & Jane'\n        ['John', 'Jane', 'Doe'] -> 'John, Jane, & Doe'\n    \"\"\"\n    # Guard against None just in case\n    if not cast:\n        return \"\"\n\n    n = len(cast)\n\n    # One name: return as is\n    if n == 1:\n        return cast[0]\n    # Two names: join with ' & '\n    if n == 2:\n        return f\"{cast[0]} & {cast[1]}\"\n    # Three or more: comma-separated, include Oxford comma before '&'\n    # Join all but last with ', ', then add ', & ' + last\n    return \", \".join(cast[:-1]) + \", & \" + cast[-1]\n", "reference_tests": [{"type": "basic", "inputs": [["Brad Pitt"]], "output": "Brad Pitt"}, {"type": "basic", "inputs": [["Brad Pitt", "Leonardo DiCaprio"]], "output": "Brad Pitt & Leonardo DiCaprio"}, {"type": "basic", "inputs": [["Brad Pitt", "Leonardo DiCaprio", "Margot Robbie"]], "output": "Brad Pitt, Leonardo DiCaprio, & Margot Robbie"}, {"type": "edge_case", "inputs": [[]], "output": ""}, {"type": "edge_case", "inputs": [["A", "B", "C", "D"]], "output": "A, B, C, & D"}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Turn a list of actor names into a readable credits string"}, {"shard_id": 2, "shard": "Single name stays unchanged two names join with space ampersand space in middle"}, {"shard_id": 3, "shard": "For three or more separate earlier names by comma then comma ampersand before last"}, {"shard_id": 4, "shard": "Input is list output is single string empty list returns empty string"}]}}, {"problem_id": 98, "category": "validation", "name": "validate_rating_string", "domain": "entertainment", "description": "Check rating string like 'PG-13', ensuring prefix in {G,PG,PG-13,R,NC-17} exactly matches. Return bool.", "verified": true, "reference_solution": "def validate_rating_string(rating: str) -> bool:\n    \"\"\"Return True iff the provided rating string is exactly one of the\n    MPAA ratings: 'G', 'PG', 'PG-13', 'R', or 'NC-17'. The match is\n    case-sensitive and must be an exact match (no surrounding spaces).\"\"\"\n    valid_ratings = {\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"}\n    return rating in valid_ratings\n", "reference_tests": [{"type": "basic", "inputs": ["G"], "output": true}, {"type": "basic", "inputs": ["PG-13"], "output": true}, {"type": "edge_case", "inputs": ["pg"], "output": false}, {"type": "edge_case", "inputs": ["PG13"], "output": false}, {"type": "edge_case", "inputs": ["NC-17"], "output": true}, {"type": "edge_case", "inputs": ["NC -17"], "output": false}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Check a film rating text matches approved standard tags exactly"}, {"shard_id": 2, "shard": "Recognize tags G PG PG dash thirteen R and NC dash seventeen"}, {"shard_id": 3, "shard": "Match must be identical including capital letters no padding spaces"}, {"shard_id": 4, "shard": "Output boolean true when tag valid otherwise false"}]}}, {"problem_id": 99, "category": "statistics", "name": "box_office_percent_change", "domain": "entertainment", "description": "Compute week-over-week percentage change list for gross earnings, rounded one decimal; first week change is None.", "sample_type": "code_synthetic"}, {"problem_id": 100, "category": "filtering", "name": "filter_short_trailers", "domain": "entertainment", "description": "Return URLs of trailers shorter than max_seconds and hosted on given domain substrings list.", "verified": true, "reference_solution": "def filter_short_trailers(trailers, max_seconds, domain_substrings):\n    \"\"\"Return a list with the URLs of trailers whose duration is strictly\n    less than `max_seconds` and whose URL contains at least one substring\n    from `domain_substrings`.\n\n    Parameters\n    ----------\n    trailers : list of dict\n        Each dict must have the keys:\n            - 'url': str  -> the URL of the trailer\n            - 'duration': int or float -> duration of the trailer in seconds\n    max_seconds : int or float\n        The maximum duration (exclusive) a trailer is allowed to have to be kept.\n    domain_substrings : list of str\n        A list of substrings. A trailer's URL must contain *one* of these\n        substrings to qualify.\n    \"\"\"\n    if not trailers or not domain_substrings:\n        return []\n\n    result = []\n    for trailer in trailers:\n        try:\n            url = trailer[\"url\"]\n            duration = trailer[\"duration\"]\n        except (TypeError, KeyError):\n            # Skip malformed entries\n            continue\n\n        if duration < max_seconds and any(sub in url for sub in domain_substrings):\n            result.append(url)\n    return result", "reference_tests": [{"type": "basic", "inputs": [[{"url": "https://youtube.com/watch?v=abc", "duration": 100}, {"url": "https://vimeo.com/vid123", "duration": 80}, {"url": "https://example.com/trailer", "duration": 50}], 90, ["youtube.com", "vimeo.com"]], "output": ["https://vimeo.com/vid123"]}, {"type": "edge_case", "inputs": [[], 120, ["youtube.com"]], "output": []}, {"type": "edge_case", "inputs": [[{"url": "https://site.com/clip", "duration": 60}], 60, ["site.com"]], "output": []}, {"type": "edge_case", "inputs": [[{"url": "https://youtube.com/tr1", "duration": 30}, {"url": "https://vimeo.com/tr2", "duration": 40}], 50, []], "output": []}, {"type": "edge_case", "inputs": [[{"url": "https://YouTube.com/test", "duration": 20}, {"url": "https://vimeo.com/xyz", "duration": 19}], 25, ["youtube.com", "vimeo.com"]], "output": ["https://vimeo.com/xyz"]}], "sample_type": "code_synthetic", "sharded_instruction": {"sharded_instruction": [{"shard_id": 1, "shard": "Need movie trailer links that match some rules"}, {"shard_id": 2, "shard": "Input is list of trailer dict url duration and a time limit"}, {"shard_id": 3, "shard": "Only keep trailers shorter than limit and url has any given domains"}, {"shard_id": 4, "shard": "Return list of their urls otherwise an empty list"}]}}]